#+TITLE: Python References
#+startup: num

* Python Interpreter
- Interprets the code we give it, usually from a .py file with instructions to run.
- Normally installed under =/usr/local/bin/python3.9=.

* Syntax
Python is super easy compared to most other languages when it comes to syntax,
there's no crazy brackets, parenthesis, or other things you need to enclosure
expressions or statements in. But instead, it's mostly off of indentation.
#+begin_src python
if 5 > 2:
    print("Five is greater than two.")
#+end_src

** Python Keywords
Python has a set of keywords that are reserved words that cannot be used as variable names, function names, or any other identifiers:
- and :: A logical operator
- as :: To create an alias
- assert :: For debugging
- break :: To break out of a loop
- class :: To define a class
- continue :: To continue to the next iteration of a loop
- def :: To define a function
- del :: To delete an object
- elif :: Used in conditional statements, same as else if
- else :: Used in conditional statements
- except :: Used with exceptions, what to do when an exception occurs
- False :: Boolean value, result of comparison operations
- finally :: Used with exceptions, a block of code that will be executed no matter if there is an exception or not
- for :: To create a for loop
- from :: To import specific parts of a module
- global :: To declare a global variable
- if :: To make a conditional statement
- import :: To import a module
- in :: To check if a value is present in a list, tuple, etc.
- is :: To test if two variables are equal
- lambda :: To create an anonymous function
- None :: Represents a null value
- nonlocal :: To declare a non-local variable
- not :: A logical operator
- or :: A logical operator
- pass :: A null statement, a statement that will do nothing
- raise :: To raise an exception
- return :: To exit a function and return a value
- True :: Boolean value, result of comparison operations
- try :: To make a try...except statement
- while :: To create a while loop
- with :: Used to simplify exception handling
- yield :: To end a function, returns a generator

** Dot Notation
Allows you to call any object's data with a method, such as ~var.readlines()~.

* Comments
Comments are super basic, but let you add little notes in your code that the
interpreter will ignore.
#+begin_src python
print("Hello") # This is ignored.
# This line ignored.
#+end_src

* Variables

** global variables
#+BEGIN_SRC python :results code
x = 50

def func():
    global x
    # REASSIGN GLOBAL X FROM DEF
    x = 'NEW VALUE'
    return(f'I changed the value of x to {x}')

func()
#+END_SRC

#+begin_src python
I changed the value of x to NEW VALUE
#+end_src

** legb rule
The LEGB rule is the order Python looks for variables:

*** L:Local
Names assigned in any way within a function (~def~ or ~lambda~), and not declated
global in that function.

*** E:Enclosing
Names in the local scope of any and all enlcosing functions (~def~ or ~lambda~),
from inner to outer.

*** G:Global (module)
Names assigned at the top-levl of a module file, or declared global in a ~def~
within the file.

*** B:Build-in (Python)
Names preassigned in the built-in names module: ~open~, ~range~, ~SyntaxError~,...

* Data Types
There are four collection data types in the Python programming language:
- List :: is a collection which is ordered and changeable. Allows duplicate members.
- Tuple :: is a collection which is ordered and unchangeable. Allows duplicate members.
- Set :: is a collection which is unordered and unindexed. No duplicate members.
- Dictionary :: is a collection which is unordered, changeable and indexed. No duplicate members.

** Setting Data Types
#+begin_src python
x = str("Hello World")
x = int(20)
x = float(20.5)
x = complex(1j)
x = list(("apple", "banana", "cherry"))
x = tuple(("apple", "banana", "cherry"))
x = range(6)
x = dict(name="John", age=36)
x = set(("apple", "banana", "cherry"))
x = frozenset(("apple", "banana", "cherry"))
x = bool(5)
x = bytes(5)
x = bytearray(5)
x = memoryview(bytes(5))
#+end_src

** Binary

** Boolean

*** booleans
Booleans are basic operators to indicate *true* or *false*.
#+BEGIN_SRC python :results code
print(10 > 9)
print(10 == 9)
print(10 < 9)
#+END_SRC

** Mapping

*** dictionaries
:PROPERTIES:
:ID:       0eab086d-0722-48c1-b591-400dfee55323
:END:
A dictionary is basically a way to index specific values inside of a variable,
so we can always know where in the variable that data is stored. Dictionary
items are unordered, changeable and unique.

Dictionaries are also a great way to keep track of a number of iterations a
value appears.
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
print(thisdict)
print(thisdict["brand"])
#+end_src

**** Accessing dictionaries
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
x = thisdict["model"]

# Use the GET method
x = thisdict.get("model")
#+end_src

**** Get Dictionary Keys
#+begin_src python
 car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.keys()

print(x) #before the change

car["color"] = "white"

print(x) #after the change
#+end_src

**** Get Dictonary Values
#+begin_src python
car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.values()

print(x) #before the change

car["year"] = 2020

print(x) #after the change
#+end_src

**** Get Dictionary Items
#+begin_src python
car = {
"brand": "Ford",
"model": "Mustang",
"year": 1964
}

x = car.items()

print(x) #before the change

car["year"] = 2020

print(x) #after the change
#+end_src

**** Check if Dictionary key exist
#+begin_src python
 thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
if "model" in thisdict:
  print("Yes, 'model' is one of the keys in the thisdict dictionary")
#+end_src

**** Changing dictionary key value
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict["year"] = 2018
#+end_src

**** Using Update method to change dictionary
#+begin_src python
 thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.update({"year": 2020})
#+end_src

**** Adding New Dictionary Items
#+begin_src python
 thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict["color"] = "red"
print(thisdict)
#+end_src

**** Adding new Dictionary Items with Update
#+begin_src python
 thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.update({"color": "red"})
#+end_src

**** Remove from Dictionary with pop
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.pop("model")
print(thisdict)
#+end_src

**** Remove item from Dictionary with popitem
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.popitem()
print(thisdict)
#+end_src

**** Clear dictionary
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
thisdict.clear()
print(thisdict)
#+end_src

**** Looping dictionary
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}

# Print all values in dictionary
for x in thisdict:
  print(x)

# Print values one by one
for x in thisdict:
  print(thisdict[x])

# Return value of a dictionary
for x in thisdict.values():
  print(x)

# Use keys method to return keys in dictionary
for x in thisdict.keys():
  print(x)

# Loop through both keys and values, using items method.
for x, y in thisdict.items():
  print(x, y)
#+end_src

**** Copy dictionary
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = thisdict.copy()
print(mydict)
#+end_src

**** Make a copy with dict()
#+begin_src python
thisdict = {
  "brand": "Ford",
  "model": "Mustang",
  "year": 1964
}
mydict = dict(thisdict)
print(mydict)
#+end_src

**** Nested Dictionary
#+begin_src python
myfamily = {
  "child1" : {
    "name" : "Emil",
    "year" : 2004
  },
  "child2" : {
    "name" : "Tobias",
    "year" : 2007
  },
  "child3" : {
    "name" : "Linus",
    "year" : 2011
  }
}

child1 = {
  "name" : "Emil",
  "year" : 2004
}
child2 = {
  "name" : "Tobias",
  "year" : 2007
}
child3 = {
  "name" : "Linus",
  "year" : 2011
}

myfamily = {
  "child1" : child1,
  "child2" : child2,
  "child3" : child3
}
#+end_src

**** Dictionary Methods
- clear() :: Removes all the elements from the dictionary
- copy() :: Returns a copy of the dictionary
- fromkeys() :: Returns a dictionary with the specified keys and value
- get() :: Returns the value of the specified key
- items() :: Returns a list containing a tuple for each key value pair
- keys() :: Returns a list containing the dictionary's keys
- pop() :: Removes the element with the specified key
- popitem() :: Removes the last inserted key-value pair
- setdefault() :: Returns the value of the specified key. If the key does not exist: insert the key, with the specified value
- update() :: Updates the dictionary with the specified key-value pairs
- values() :: Returns a list of all the values in the dictionary

**** storing data in dictionaries
The times you would want to use a *dictionary vs a regular list* is when you need
to know where something is preceily, and call it. A dictionary is also *not*
sort-able.

The breakout of a dictionary is: ={'key':'value'}=
#+BEGIN_SRC python
my_dict = {'key1':'data1','key2':'data2'}
return my_dict['key1']
#+END_SRC

***** condition checks against dictionaries
:PROPERTIES:
:ID:       a004060b-2029-4fd0-8316-a1fb6c4b8a41
:END:
NOTE: about storing data... you can run a boolean test against your dictionary
to see if something exist in the following way:
#+BEGIN_SRC python
d = {'key1':'data1','key2':'data2'}
'data1' in d.values() # will test if data1 exist as a value stored in your dictionary
'key1' in d.keys() # will test if key1 exist as a key in your dictionary
#+END_SRC

**** multiple data types in dictionaries
You can store multiple object types, including *lists* and other *dictionaries*.
Here's an example:
#+BEGIN_SRC python
my_dict = {'k1':123,'k2':[0,1,2,3],'k3':{'kn1':'string','kn2':'more data'}}
return my_dict['k2'][1:]
return my_dict['k3']['kn2']
#+END_SRC

**** passing methods to dictionaries
:PROPERTIES:
:ID:       d66faf96-f82a-44f6-b269-513f23373cef
:END:
Calling a method with a dictionary is very similar to the way we've done it
before, but we can call the whole operation in one function as such:
#+BEGIN_SRC python
my_dict = {'k1':'string','k2':'more data'}
return my_dict['k2'].upper()
#+END_SRC

**** changing a dictionary
#+BEGIN_SRC python
ddd = {'age':21,'course':182}
ddd['age'] = 23
return(ddd)
#+END_SRC

** Numberic
Convert from one type to another.
#+begin_src python
x = 1    # int
y = 2.8  # float
z = 1j   # complex

#convert from int to float:
a = float(x)

#convert from float to int:
b = int(y)

#convert from int to complex:
c = complex(x)

print(a)
print(b)
print(c)
#+end_src

*** int
#+begin_src python
x = 1
y = 35656222554887711
z = -3255522
#+end_src

*** float
#+begin_src python
x = 1.10
y = 1.0
z = -35.59

# Float can also be scientific numbers with an "e" indicate the power of 10.
x = 35e3
y = 12E4
z = -87.7e100
#+end_src

*** complex
#+begin_src python
x = 3+5j
y = 5j
z = -5j

# Complex numbers are written with a "j" as the imaginary part
#+end_src

** Sequence

*** lists
Lists are enclosed in =[]='s, *double quotes* for strings =,= to sepearte our indexes
and yes, indexes to call different index slots of our list.

#+BEGIN_SRC python
list = [1, 2, "test", "data", "my string"]
print(list[2])
#+END_SRC

**** Lists indexes
Since these are stored at indexes, you can change parts of your list by calling
the index number and then assigning it to a new value.
#+BEGIN_SRC python
list = ["list" "free data" "hello world" "my name is "]
list[0] = "last"
list

# You can also use negative indexing
list[-1]
# last
#+END_SRC

**** Lists Ranges
#+begin_src python
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "melon", "mango"]
print(thislist[2:5])

#This will return the items from position 2 to 5.

#Remember that the first item is position 0,
#and note that the item in position 5 is NOT included
#+end_src

**** Check if data exist in Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
if "apple" in thislist:
  print("Yes, 'apple' is in the fruits list")
#+end_src

**** Change lists data at index
#+begin_src python
thislist = ["apple", "banana", "cherry"]
thislist[1] = "blackcurrant"
print(thislist)

# Change the second value by replacing it with two new values:
thislist = ["apple", "banana", "cherry"]
thislist[1] = ["blackcurrant", "watermelon"]
print(thislist)

# Cahnge a range of items
thislist = ["apple", "banana", "cherry", "orange", "kiwi", "mango"]
thislist[1:3] = ["blackcurrant", "watermelon"]
print(thislist)
#+end_src

**** Insert after index retaining existing data
#+begin_src python
thislist = ["apple", "banana", "cherry"]
thislist.insert(2, "watermelon")
print(thislist)
#+end_src

**** Append to end of Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
thislist.append("orange")
print(thislist)
#+end_src

**** Insert item to Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
thislist.insert(1, "orange")
print(thislist)
#+end_src

**** Remove item from Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
thislist.remove("banana")
print(thislist)
#+end_src

**** Pop removes item from Lists
Another method is ~.pop~, which will pop off the last value of the list and return
it.
#+BEGIN_SRC python
list = ["first" "second"]
list.pop()
# If you do not specify the index, the pop() method removes the last item.

# alternatively you can pass the index number you want to pop
list.pop(0)
#+END_SRC

**** Using Del to remove from Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
del thislist[0]
print(thislist)

# Can also delete the entire lists
thislist = ["apple", "banana", "cherry"]
del thislist
#+end_src

**** Clear Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
thislist.clear()
print(thislist)
#+end_src

**** Loop through Lists
#+begin_src python
wlist = [2,4,5,6,7,8]
index = 0

# One way is using pop if you want pull everything out of the list, this is destructive though.
while len(wlist) > 0:
    print(list.pop(wlist))

# Another way is incrementing the index ingeger until it's higher than the length of the variable name.
while index < len(wlist):
    index = index + 1
    print(wlist)

thislist = ["apple", "banana", "cherry"]
for x in thislist:
  print(x)

# Loop through index numbers
thislist = ["apple", "banana", "cherry"]
for i in range(len(thislist)):
  print(thislist[i])

# List Comprehensive offers the shortest syntax for looping through lists:
thislist = ["apple", "banana", "cherry"]
[print x for x in thislist]
#+end_src

**** List Comprehension
List comprehension, basically just allows you to write out your code in one line
inside =[]= brackets.

The Syntax: \\
~newlist = [expression for item in iterable if condition == True]~

#+begin_src python
# Normal for loop
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]
newlist = []

for x in fruits:
  if "a" in x:
    newlist.append(x)

print(newlist)

# With a comprehension you get
fruits = ["apple", "banana", "cherry", "kiwi", "mango"]

newlist = [x for x in fruits if "a" in x]

print(newlist)

# With no if statement
newlist = [x for x in fruits]

# Using a range()
newlist = [x for x in range(10)]

# Accept only numbers less than
newlist = [x for x in range(10) if x < 5]
#+end_src

**** Copy Lists
#+begin_src python
thislist = ["apple", "banana", "cherry"]
mylist = thislist.copy()
print(mylist)

# Example using the list() function
thislist = ["apple", "banana", "cherry"]
mylist = list(thislist)
print(mylist)
#+end_src

**** Join Lists
#+begin_src python
list1 = ["a", "b", "c"]
list2 = [1, 2, 3]

list3 = list1 + list2
print(list3)

# Alternatively use a for loop with append
list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]

for x in list2:
  list1.append(x)

print(list1)

# Lastly use the extend() function
list1 = ["a", "b" , "c"]
list2 = [1, 2, 3]

list1.extend(list2)
print(list1)
#+end_src

**** List Methods
- append() :: Adds an element at the end of the list
- clear() :: Removes all the elements from the list
- copy() :: Returns a copy of the list
- count() :: Returns the number of elements with the specified value
- extend() :: Add the elements of a list (or any iterable), to the end of the current list
- index() :: Returns the index of the first element with the specified value
- insert() :: Adds an element at the specified position
- pop() :: Removes the element at the specified position
- remove() :: Removes the item with the specified value
- reverse() :: Reverses the order of the list
- sort() :: Sorts the list

**** Extend List with another list
#+begin_src python
thislist = ["apple", "banana", "cherry"]
tropical = ["mango", "pineapple", "papaya"]
thislist.extend(tropical)
print(thislist)

# The extend() method does not have to append lists, you can add any iterable object (tuples, sets, dictionaries etc.).#+end_src
thislist = ["apple", "banana", "cherry"]
thistuple = ("kiwi", "orange")
thislist.extend(thistuple)
print(thislist)

**** Lists can hold multiple data types
#+begin_src python
list1 = ["abc", 34, True, 40, "male"]
#+end_src

**** Append to Lists
You can also append new data to a list by using the ~.append~ method.
#+BEGIN_SRC python
list = ["my list"]
list.append("data")
return(list)
#+END_SRC

**** Sort Lists
There's also the ~.reverse~ method, which like sort, will reverse sort your list.
#+BEGIN_SRC python
thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort()
print(thislist)

# Reversing the order
thislist = ["orange", "mango", "kiwi", "pineapple", "banana"]
thislist.sort(reverse = True)
print(thislist)

thislist = ["banana", "Orange", "Kiwi", "cherry"]
thislist.reverse()
print(thislist)

# Sorting by lower case characters first
thislist = ["banana", "Orange", "Kiwi", "cherry"]
thislist.sort(key = str.lower)
print(thislist)
#+END_SRC
**** Getting to nested data
#+begin_src python :results code
nested = [['a', 'b', 'c'],['d', 'e', 'f'],['g', 'h', 'i']]

return(nested[1][0])
#+end_src

#+begin_src python
d
#+end_src

*** tuples
Tuples are very similar to lists, but the key difference is they have
immutability. Tuples are in parenthesis ~(1,2,3)~.

#+begin_src python
thistuple = ("apple", "banana", "cherry")
print(thistuple)
#+end_src

**** Accessing tuple index
#+begin_src python
thistuple = ("apple", "banana", "cherry")
print(thistuple[1])

# Negative Indexing
thistuple = ("apple", "banana", "cherry")
print(thistuple[-1])
#+end_src

**** Range of indexes
#+begin_src python
thistuple = ("apple", "banana", "cherry", "orange", "kiwi", "melon", "mango")
print(thistuple[2:5])
#+end_src

**** Change tuple value
#+begin_src python
x = ("apple", "banana", "cherry")
y = list(x)
y[1] = "kiwi"
x = tuple(y)

print(x)
#+end_src

**** Loop through tuple
#+begin_src python
thistuple = ("apple", "banana", "cherry")
for x in thistuple:
  print(x)
#+end_src

**** Check if item exist in tuple
#+begin_src python
thistuple = ("apple", "banana", "cherry")
if "apple" in thistuple:
  print("Yes, 'apple' is in the fruits tuple")
#+end_src

**** Add items to tuple
You cannot add items to tuple...

**** Remove item from tuple
Tuples cannot be modified, but you can ~del~ the tuple.
#+begin_src python
thistuple = ("apple", "banana", "cherry")
del thistuple
print(thistuple) #this will raise an error because the tuple no longer exists
#+end_src

**** Join two tuples
#+begin_src python
tuple1 = ("a", "b" , "c")
tuple2 = (1, 2, 3)

tuple3 = tuple1 + tuple2
print(tuple3)
#+end_src

**** tuple methods
:PROPERTIES:
:ID:       56779402-9af7-4086-b605-f842634f1a42
:END:
- count() :: Returns the number of times a specified value occurs in a tuple
- index() :: Searches the tuple for a specified value and returns the position of where it was found

*** ranges
To create a range of numbers. The number =0= is the start of the range, the =10= is
the end of the range and the =2= is telling it to increment by this number.
#+BEGIN_SRC python
for num in range(0,10,2):
    print(num)
#+END_SRC

** Set

*** sets
A set is a collection which is unordered, unindexed and unique. In Python, sets
are written with curly brackets.
#+begin_src python
thisset = {"apple", "banana", "cherry"}
print(thisset)
#+end_src

**** Adding data to sets
Just add using the ~.add~ method
#+BEGIN_SRC python
my_set = set()
my_set.add(1)
my_set.add('string')
my_set()
#+END_SRC

Another useful way of using this is passing a list back to your set
#+BEGIN_SRC python
my_list = [1,1,1,2,2,2,3,3,3,4,5]
set(my_list)
return set(my_list)
#+END_SRC

**** Loop through sets
#+begin_src python
thisset = {"apple", "banana", "cherry"}

for x in thisset:
  print(x)
#+end_src

**** Check if data exist in sets
#+begin_src python
thisset = {"apple", "banana", "cherry"}

print("banana" in thisset)
#+end_src

**** Changing items in sets
You cannot change or modify what's already in the set.

**** Adding to sets
#+begin_src python
thisset = {"apple", "banana", "cherry"}

thisset.add("orange")

print(thisset)
#+end_src

**** Add multiple items with update
#+begin_src python
thisset = {"apple", "banana", "cherry"}

thisset.update(["orange", "mango", "grapes"])

print(thisset)
#+end_src

**** Remove item from set
#+begin_src python
thisset = {"apple", "banana", "cherry"}

thisset.remove("banana")

print(thisset)
#+end_src

**** Using discard to remove from sets
#+begin_src python
thisset = {"apple", "banana", "cherry"}

thisset.discard("banana")

print(thisset)
#+end_src

**** Using pop to remove item from sets
#+begin_src python
thisset = {"apple", "banana", "cherry"}

x = thisset.pop()

print(x)

print(thisset)
#+end_src

**** Clear sets
#+begin_src python
thisset = {"apple", "banana", "cherry"}

thisset.clear()

print(thisset)
#+end_src

**** Join two sets
#+begin_src python
set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}

set3 = set1.union(set2)
print(set3)
#+end_src

**** Join sets with update method
#+begin_src python
set1 = {"a", "b" , "c"}
set2 = {1, 2, 3}

set1.update(set2)
print(set1)
#+end_src

**** Sets methods
- add() :: Adds an element to the set
- clear() :: Removes all the elements from the set
- copy() :: Returns a copy of the set
- difference() :: Returns a set containing the difference between two or more sets
- difference_update() :: Removes the items in this set that are also included in another, specified set
- discard() :: Remove the specified item
- intersection() :: Returns a set, that is the intersection of two other sets
- intersection_update() :: Removes the items in this set that are not present in other, specified set(s)
- isdisjoint() :: Returns whether two sets have a intersection or not
- issubset() :: Returns whether another set contains this set or not
- issuperset() :: Returns whether this set contains another set or not
- pop() :: Removes an element from the set
- remove() :: Removes the specified element
- symmetric_difference() :: Returns a set with the symmetric differences of two sets
- symmetric_difference_update() :: inserts the symmetric differences from this set and another
- union() :: Return a set containing the union of sets
- update() :: Update the set with the union of this set and others

** Text

*** strings
:PROPERTIES:
:ID:       92ab1fbc-b855-4144-bf93-3e96ff56790b
:END:

**** assigning strings to variables
#+begin_src python
x = "Hello"
print(x)
#+end_src

**** multiline strings
#+begin_src python
a = """Lorem ipsum dolor sit amet,
consectetur adipiscing elit,
sed do eiusmod tempor incididunt
ut labore et dolore magna aliqua."""
#+end_src

**** string concatenation
#+begin_src python
x = "Hello"
y = "world"
print(x + " " + y)
#Hello World
#+end_src

**** strings are arrays
Meaning you can extract the character at index position(x)
#+begin_src python
mystring = "Hello"
print(mystring[1])
#+end_src

**** slicing strings
#+BEGIN_SRC python :results code
x = 'hello'
print(x[0:4])
# hell

# Use negative numbers to start from the end of the string
print(x[-4:-2])
#+END_SRC

#+begin_src python
hell
#+end_src

**** length of string
#+begin_src python :results code
x = "Hello"
return(len(x))
# 5
#+end_src

**** double splitting strings
:PROPERTIES:
:ID:       a17d85a3-9950-439b-a8e7-6e0bf59f464c
:END:
#+BEGIN_SRC python
x = 'From: nick-dev@test.us.com Sat Jan 5 09:14:16 2008'
split = x.split()
email = split[1]
user = email.split('@')
return(user[0])
#+END_SRC

**** splitting strings
The ~.split~ method allows you to pass a delimeter as the argument to split your
strings:
#+BEGIN_SRC python :results code
x = 'first;second;third'
x_split = x.split(';')
return(x_split)
#+END_SRC

#+begin_src python
['first', 'second', 'third']
#+end_src

Another example of how we can use the ~string.split~ method is taking the header
line from an email, and splitting the text into different indexes.
#+BEGIN_SRC python
fhand = open('file.txt')
for line in fhand:
    line = line.rstrip() # Cleans up whitespaces
    if not line.startswith('From ') :
        continue
    words = line.split()
    print(words[2])
#+END_SRC

**** using comparison operators on strings
Python can do a comparison operation against strings to see if the letters in
the word, are greater or lower in indexing than it's opposite. So for instance ~C
> B = TRUE~ because C is higher in the index than B.
#+begin_src python :results none :exports code
x = 'chuck'
y = 'glen'

return x > y
#+end_src

#+begin_src python
False
#+end_src

**** string methods
Here's a list of available methods:
- capitalize() :: Converts the first character to upper case
- casefold() :: Converts string into lower case
- center() :: Returns a centered string
- count() :: Returns the number of times a specified value occurs in a string
- encode() :: Returns an encoded version of the string
- endswith() :: Returns true if the string ends with the specified value
- expandtabs() :: Sets the tab size of the string
- find() :: Searches the string for a specified value and returns the position of where it was found
- format() :: Formats specified values in a string
- format_map() :: Formats specified values in a string
- index() :: Searches the string for a specified value and returns the position of where it was found
- isalnum() :: Returns True if all characters in the string are alphanumeric
- isalpha() :: Returns True if all characters in the string are in the alphabet
- isdecimal() :: Returns True if all characters in the string are decimals
- isdigit() :: Returns True if all characters in the string are digits
- isidentifier() :: Returns True if the string is an identifier
- islower() :: Returns True if all characters in the string are lower case
- isnumeric() :: Returns True if all characters in the string are numeric
- isprintable() :: Returns True if all characters in the string are printable
- isspace() :: Returns True if all characters in the string are whitespaces
- istitle() :: Returns True if the string follows the rules of a title
- isupper() :: Returns True if all characters in the string are upper case
- join() :: Joins the elements of an iterable to the end of the string
- ljust() :: Returns a left justified version of the string
- lower() :: Converts a string into lower case
- lstrip() :: Returns a left trim version of the string
- maketrans() :: Returns a translation table to be used in translations
- partition() :: Returns a tuple where the string is parted into three parts
- replace() :: Returns a string where a specified value is replaced with a specified value
- rfind() :: Searches the string for a specified value and returns the last position of where it was found
- rindex() :: Searches the string for a specified value and returns the last position of where it was found
- rjust() :: Returns a right justified version of the string
- rpartition() :: Returns a tuple where the string is parted into three parts
- rsplit() :: Splits the string at the specified separator, and returns a list
- rstrip() :: Returns a right trim version of the string
- split() :: Splits the string at the specified separator, and returns a list
- splitlines() :: Splits the string at line breaks and returns a list
- startswith() :: Returns true if the string starts with the specified value
- strip() :: Returns a trimmed version of the string
- swapcase() :: Swaps cases, lower case becomes upper case and vice versa
- title() :: Converts the first character of each word to upper case
- translate() :: Returns a translated string
- upper() :: Converts a string into upper case
- zfill() :: Fills the string with a specified number of 0 values at the beginning

And here are some example use cases for methods:

1. Return characters in UPPER case.
   #+BEGIN_SRC python
 x = 'hello world'
 print(x.upper())
 # HELLO WORLD
   #+END_SRC
2. Return characters in LOWER case
   #+begin_src python
x = "HELLO"
print(x.lower())
# hello
   #+end_src
3. Strip whitespaces from beginning and end
   #+begin_src python :results code
 x = ' hello world '
 return(x.strip())
 # hello world
   #+end_src
4. Splitting strings by character
   #+begin_src python
x = "Hello, World"
print(x.split(","))
# ['Hello', 'World']
  #+end_src
- String formats
  #+begin_src python

  #+end_src

**** check string
#+begin_src python
txt = "The rain in Spain stays mainly in the plain"
x = "ain" in txt
print(x)
# True
#+end_src

**** .format method on strings
1. Inserting a single string.
   #+BEGIN_SRC python :results code
 print("This is a string {}".format("INSERTED"))
 # This is a string INSERTED
   #+END_SRC
2. Passing multiple strings
   #+BEGIN_SRC python :results code
 print("The {2} {1} {0}".format("fox","brown","quick"))
 # The quick brown fox
   #+END_SRC
3. Using variables to pass arguments
   #+BEGIN_SRC python :results code
 print("The {q} {b} {f}!".format(q="quick",b="brown",f="fox"))
   #+END_SRC

   #+begin_src python
 The quick brown fox!
   #+end_src
4. Using .format to limit the length of float numbers
  #+BEGIN_SRC python :results code
value = 100/777
print("The value was {r:1.3f}".format(r=value))
# The value was 0.129
  #+END_SRC

* Casting
The user explicitly changes the data type... See [[Setting Data Types]].

* Operators

** Arithmetic Operators
Arithmetic operators are used with numeric values to perform common mathematical
operations:
| Operator | Name           | Example |
|----------+----------------+---------|
| +        | Addition       | x + y   |
| -        | Subtraction    | x - y   |
| *        | Multiplication | x * y   |
| /        | Division       | x / y   |
| %        | Modulus        | x % y   |
| **       | Exponentiation | x ** y  |
| //       | Floor division | x // y  |

** Assignment Operators
Assignment operators are used to assign values to variables:
| Operator | Example    | Same As      |
|----------+------------+--------------|
| =        | x = 5      | x = 5        |
| +=       | x += 3     | x = x + 3    |
| -=       | x -= 3     | x = x - 3    |
| *=       | x *= 3     | x = x * 3    |
| /=       | x /= 3     | x = x / 3    |
| %=       | x %= 3     | x = x % 3    |
| //=      | x //= 3    | x = x // 3   |
| **=      | x **= 3    | x = x ** 3   |
| &=       | x &= 3     | x = x & 3    |
| "pipe"=  | x"pipe"= 3 | x = x"pipe"3 |
| ^=       | x ^= 3     | x = x ^ 3    |
| >>=      | x >>= 3    | x = x >> 3   |
| <<=      | x <<= 3    | x = x << 3   |

** Comparison Operators
Comparison operators are used to compare two values:
| Operator | Name                     | Example |
|----------+--------------------------+---------|
| ==       | Equal                    | x == y  |
| !=       | Not equal                | x != y  |
| >        | Greater than             | x > y   |
| <        | Less than                | x < y   |
| >=       | Greater than or equal to | x >= y  |
| <=       | Less than or equal to    | x <= y  |

** Logical Operators
Logical operators are used to combine conditional statements:
| Operator | Description                                             | Example               |
|----------+---------------------------------------------------------+-----------------------|
| and      | Returns True if both statements are true                | x < 5 and  x < 10     |
| or       | Returns True if one of the statements is true           | x < 5 or x < 4        |
| not      | Reverse the result, returns False if the result is true | not(x < 5 and x < 10) |

** Identity Operators
Identity operators are used to compare the objects, not if they are equal, but
if they are actually the same object, with the same memory location:
| Operator | Description                                            | Example    |
|----------+--------------------------------------------------------+------------|
| is       | Returns True if both variables are the same object     | x is y     |
| is not   | Returns True if both variables are not the same object | x is not y |

** Python Membership Operators
Membership operators are used to test if a sequence is presented in an object:
| Operator | Description                                                                      | Example    |
|----------+----------------------------------------------------------------------------------+------------|
| in       | Returns True if a sequence with the specified value is present in the object     | x in y     |
| not in   | Returns True if a sequence with the specified value is not present in the object | x not in y |

** Python Bitwise Operators
Bitwise operators are used to compare (binary) numbers:
| Operator | Name                 | Description                                                                                             |   |
|----------+----------------------+---------------------------------------------------------------------------------------------------------+---|
| &        | AND                  | Sets each bit to 1 if both bits are 1                                                                   |   |
| "pipe"   | OR                   | Sets eats bit to 1 if one of two bits is 1                                                              |   |
| ^        | XOR                  | Sets each bit to 1 if only one of two bits is 1                                                         |   |
| ~        | NOT                  | Inverts all the bits                                                                                    |   |
| <<       | Zero fill left shift | Shift left by pushing zeros in from the right and let the leftmost bits fall off                        |   |
| >>       | Signed right shift   | Shift right by pushing copies of the leftmost bit in from the left, and let the rightmost bits fall off |   |

* Control Structures
1. Use while loops for booleans, or while something is true/false.
2. Use for loops to iterate over elements of a sequence.
3. Recursion repetive function where it calls itself until it reaches a base condition.

** Indentation

*** using returns with a for loop and logical operators
The important thing to note here is that the return *cannot* be on the same
indented line as the if condition, otherwise as soon as it finds a False
condition it'll exit the loop.
#+BEGIN_SRC python
def check_even_list(num_list):
    for number in num_list:
        if number % 2 == 0:
            return True
        else:
            pass
    return False
#+END_SRC

Another example is to print every even number in a list.. Another note to make
here is the use of *return*, which is required in a function to return it's
results so you can later assign them to a variable. Without using the return
function, you would simply get the output from the function but cannot use it
anywhere else.
#+BEGIN_SRC python
def check_even_list(num_list):
    # here we define our static variables for the function
    even_numbers = []
    for nums in num_list:
        if number % 2 == 0:
            even_numbers.append(nums)
        else:
            pass
    return even_numbers
#+END_SRC

*** returning tuples
#+BEGIN_SRC python :results code
work_hours = [('Abby',100),('Billy',400),('Cassie',800)]

def employee_check(work_hours):
    # Set some max value to intially be at, like zero hours
    current_max = 0
    # Set some empty value before the loop
    employee_of_month = ''

    for employee,hours in work_hours:
        if hours > current_max:
            current_max = hours
            employee_of_month = employee
        else:
            pass

    # Notice the indentation here
    return (employee_of_month,current_max)

return employee_check(work_hours)
#+END_SRC

#+begin_src python
('Cassie', 800)
#+end_src

*** returning variables from your function
#+BEGIN_SRC python :results code
x = 50

def func(x):
    print(f'X is {x}')

    x = 'NEW VALUE'
    return x
return func(x)
#+END_SRC

#+begin_src python
NEW VALUE
#+end_src

*** nested statements
So let's dive into an example, where we define two ~def~ inside one another.
#+BEGIN_SRC python :results code
def greet():

    name = 'Sammy'

    def hello():
        print('Hello '+name)

    hello()

greet()
#+END_SRC

#+RESULTS:
#+begin_src python
Hello Sammy
#+end_src

** IF ELSE IFELSE Statements
Python supports the usual logical conditions from mathematics:
- Equals: ~a == b~
- Not Equals: ~a ! b~
- Less than: ~a < b~
- Less than or equal to: ~a <= b~
- Greater than: ~a > b~
- Greater than or equal to: ~a >= b~

These statements are your basics for running code depending on when a condition
comes back *True* or *else*.
#+BEGIN_SRC python
if (3 > 2):
    print('Its true!')
#+END_SRC

*** IF ELSE
#+BEGIN_SRC python
hungry = True
if hungry:
    print('Feed me!')
else:
    print('Not hungry')
#+END_SRC

*** IF ELIF ELSE
#+BEGIN_SRC python
loc = 'Bank'

if loc == 'Auto Shop':
    print('I like cars')
elif loc == 'Bank':
    print('Money is cool')
elif loc == 'Grocery Store':
    print('Get me food!')
else:
    print('I don\'t know much')
#+END_SRC

*** Short Hand IF
#+begin_src python
if a > b: print("a is greater than b")
#+end_src

*** Short Hand If ... Else
This technique is known as *Ternary Operators*, or *Conditional Expressions*.
#+begin_src python
a = 2
b = 330
print("A") if a > b else print("B")

# You can also have multiple ELSE statements
print("A") if a > b else print("=") if a == b else print("B")
#+end_src

*** And Logical Operator with IF
#+begin_src python
a = 200
b = 33
c = 500
if a > b and c > a:
  print("Both conditions are True")
#+end_src

*** Or Logical Operator with IF
#+begin_src python
a = 200
b = 33
c = 500
if a > b or a > c:
  print("At least one of the conditions is True")
#+end_src

*** Nested IF
#+begin_src python
x = 41

if x > 10:
  print("Above ten,")
  if x > 20:
    print("and also above 20!")
  else:
    print("but not above 20.")
#+end_src

*** The Pass Statement with IF
Something to consider...
#+begin_src python
a = 33
b = 200

if b > a:
  pass
#+end_src

** Loops and Control Statements

** For
The *for* statement is a great statement to run through a list of items and
perform an action on each of those items in the list.

#+BEGIN_SRC python
list = [1,2,3,4,5]
for num in list:
    print(num)
#+END_SRC

*** FOR with IF and ELSE statements
The below example will print out all your event numbers, and odd numbers will
return the string =Odd number is $var=.
#+BEGIN_SRC python
list = [1,2,3,4,5,6]
for num in list:
    if num % 2 == 0:
        print(num)
    else:
        print(f'Odd number is {num}')
#+END_SRC

*** FOR loop to calculate total
Another method of using this is to calculate and give you the total, or output
the output after each loop.
#+BEGIN_SRC python
list = [1,2,3,4,5,6,7,8,9,10]
list_sum = 0
for num in list:
    list_sum = list_sum + num
    print(list_sum)
return print(list_sum)
#+END_SRC

*** FOR loop with tuples printing both indexes
And for indexing, you can pass two arguments to essentially act as the index
number:
#+BEGIN_SRC python
list = [(1,2)(3,4)(5,6)(7,8)]
for a,b in list:
    print(a)
    print(b)

for a,b in list:
    if a % 2 == 0:
        print('Even number detected {a}')
    elif b % 2 == 0:
        print('The number is even {b}')
    else:
        print('No numbers returned')

return(type(list))
#+END_SRC

*** FOR loop with Dictionaries
For dictionaries it's a little different
#+BEGIN_SRC python
d = {'key1':'string1','key2':'string2'}
for key,value in d.items():
    print(value)
#+END_SRC

*** Break FOR loop when IF condition is true
#+begin_src python
 fruits = ["apple", "banana", "cherry"]
for x in fruits:
  print(x)
  if x == "banana":
    break
#+end_src

** While
While loops will run through a body of code long as the condition remains *true*.
#+BEGIN_SRC python
x = 5
while x < 5:
    print(f'The value of x is {x}')
    x = x + 1
else:
    print('X is not less than 5')
#+END_SRC

*** while loop list and output results
#+BEGIN_SRC python
wlist = [2,4,5,6,7,8]
index = 0

# One way is using pop if you want pull everything out of the list
while len(wlist) > 0:
    print(list.pop(wlist))

# Another way is incrementing the index ingeger until it's higher than the length of the variable name.
index = 0
while index < len(wlist):
    index = index + 1
    print(wlist)

#+END_SRC

*** While Break Statement
With the break statement we can stop the loop even if the while condition is
true:
#+begin_src python
i = 1
while i < 6:
  print(i)
  if i == 3:
    break
  i += 1
#+end_src

*** While Continue Statement
With the continue statement we can stop the current iteration, and continue with
the next:
#+begin_src python
i = 0
while i < 6:
  i += 1
  if i == 3:
    continue
  print(i)
#+end_src

*** While Else Statement
With the else statement we can run a block of code once when the condition no
longer is true:
#+begin_src python
i = 1
while i < 6:
  print(i)
  i += 1
else:
  print("i is no longer less than 6")
#+end_src

** Recursion
#+begin_src python
def factorial(n):
    if n < 2:
        return 1
    return n * factory(n-1)
#+end_src

** Loop Control with Break and Continue
These statements add more functionality to your loop conditions
- break: Breaks out of the current closes loop
- continue: Goes to hte top of the closest loop
- pass: Does nothing at all

The pass keyword helps if you need to build out your loop condition, but want to
save it for later...
#+BEGIN_SRC python
x = [1,2,3]
for item in x:
    pass
#+END_SRC

The closest statement basically tells python to skip the current cycle and go
back to the beginning of the sequence, while skipping the result if it matches
your condition.
#+BEGIN_SRC python
x = 'Sammy'
for letters in x:
    if letters == 'a':
        continue
    print(letters)
#+END_SRC

The break statement is a little different, if the conditon you're searhcing for
returns true and you have a break statement, python will break out of that loop
and move to the next piece of code:
#+BEGIN_SRC python
x = 'Sammy'
for letters in x:
    if letters == 'a':
        break
    print(letters)
#+END_SRC

** Functions

*** Finding help on functions
Call help to see the built-in documentation for a function.
#+BEGIN_SRC python
mylist = {'key1':'string1','key2':'string2'}
help(mylist.insert)
#+END_SRC

*** building new functions
Functions are essentially a bunch of instructions that are bundled and defined
by an object name. Once you assign or create a new function, when you execute
that function it'll carry out all the instructions inside of that function. So
for example:
#+BEGIN_SRC python
def hello_world(name):
    "Function that prints hello world + NAME."
    print(f'Hello {name}')

hello_world('Nick')
#+END_SRC

If you want to pass a default argument value, you can arrange it so
#+BEGIN_SRC python
def hello_world(name='User'):
    "Function."
    print(f'Hello {name}')
hello_world()
#+END_SRC

You can also use the ~return~ function to save the results of your function to a
variable, so it's stored in memory.
#+BEGIN_SRC python :results code
def sum_numbers(num1,num2):
    return num1+num2
result = sum_numbers(10,37)
return result
#+END_SRC

#+begin_src python
47
#+end_src

**** docstrings
Can contain multiple lines of comments, that will not be read by the compiler
and used to help explain a function. You often need to start and end the
docstring with 3 ~"""~ on a single line before and after your docstring.

*** interactions between functions
Sometimes you'll want to pass results from one function back to another...
#+BEGIN_SRC python
def shuffle_list(mylist):
    # Take in list, and returned shuffle versioned
    shuffle(mylist)

    return mylist


def player_guess():

    guess = ''

    while guess not in ['0','1','2']:

        # Recall input() returns a string
        guess = input("Pick a number: 0, 1, or 2:  ")

    return int(guess)

def check_guess(mylist,guess):
    if mylist[guess] == 'O':
        print('Correct Guess!')
    else:
        print('Wrong! Better luck next time')
        print(mylist)

# Initial List
mylist = [' ','O',' ']

# Shuffle It
mixedup_list = shuffle_list(mylist)

# Get User's Guess
guess = player_guess()

# Check User's Guess
#------------------------
# Notice how this function takes in the input
# based on the output of other functions!
check_guess(mixedup_list,guess)
#+END_SRC

*** *args and **kwargs
What if you need to allow an unlimited number of arguments to be passed to a
function? Well adding those by hand is not very efficient, but instead what you
can do is use a method to tell the function to accept all those arguments.

**** the *args method
This seems to be efficient when dealing with numbers, and treats the results as
a *tuples* list.
#+BEGIN_SRC python
def myfunc(*args):
    results = *args * 0.15
    return results
#+END_SRC

**** the **kwargs method
So what about passing a number of strings?
#+BEGIN_SRC python
def myfunc(**kwargs):
    print(kwargs)
    if 'fruit' in kwargs:
        print('My fruit of choice is {}.'.format(kwargs['fruit']))
    else:
        print('I did not find any fruit here.')

myfunc(fruit='apple',veggie='lettuce')
#+END_SRC

**** accepting both *args and **kwargs
:PROPERTIES:
:ID:       906da043-39b6-496c-a428-dd84849e5e48
:END:
#+BEGIN_SRC python
def myfunc(*args,**kwargs):
    print('I would like {} of {}.'.format(args[0],kwargs['food']))

myfunc(10,20,30,fruit='oranges',food='eggs',food='tacos')
#+END_SRC

*** The return statement
A return statement is used to end the execution of the function call and
“returns” the result (value of the expression following the return keyword) to
the caller. The statements after the return statements are not executed. If the
return statement is without any expression, then the special value None is
returned.

** Lambda

** Statements

* Functions
- abs() :: Returns the absolute value of a number
- all() :: Returns True if all items in an iterable object are true
- any() :: Returns True if any item in an iterable object is true
- ascii() :: Returns a readable version of an object. Replaces none-ascii characters with escape character
- bin() :: Returns the binary version of a number
- bool() :: Returns the boolean value of the specified object
- bytearray() :: Returns an array of bytes
- bytes() :: Returns a bytes object
- callable() :: Returns True if the specified object is callable, otherwise False
- chr() :: Returns a character from the specified Unicode code.
- classmethod() :: Converts a method into a class method
- compile() :: Returns the specified source as an object, ready to be executed
- complex() :: Returns a complex number
- delattr() :: Deletes the specified attribute (property or method) from the specified object
- dict() :: Returns a dictionary (Array)
- dir() :: Returns a list of the specified object's properties and methods
- divmod() :: Returns the quotient and the remainder when argument1 is divided by argument2
- enumerate() :: Takes a collection (e.g. a tuple) and returns it as an enumerate object
- eval() :: Evaluates and executes an expression
- exec() :: Executes the specified code (or object)
- filter() :: Use a filter function to exclude items in an iterable object
- float() :: Returns a floating point number
- format() :: Formats a specified value
- frozenset() :: Returns a frozenset object
- getattr() :: Returns the value of the specified attribute (property or method)
- globals() :: Returns the current global symbol table as a dictionary
- hasattr() :: Returns True if the specified object has the specified attribute (property/method)
- hash() :: Returns the hash value of a specified object
- help() :: Executes the built-in help system
- hex() :: Converts a number into a hexadecimal value
- id() :: Returns the id of an object
- input() :: Allowing user input
- int() :: Returns an integer number
- isinstance() :: Returns True if a specified object is an instance of a specified object
- issubclass() :: Returns True if a specified class is a subclass of a specified object
- iter() :: Returns an iterator object
- len() :: Returns the length of an object
- list() :: Returns a list
- locals() :: Returns an updated dictionary of the current local symbol table
- map() :: Returns the specified iterator with the specified function applied to each item
- max() :: Returns the largest item in an iterable
- memoryview() :: Returns a memory view object
- min() :: Returns the smallest item in an iterable
- next() :: Returns the next item in an iterable
- object() :: Returns a new object
- oct() :: Converts a number into an octal
- open() :: Opens a file and returns a file object
- ord() :: Convert an integer representing the Unicode of the specified character
- pow() :: Returns the value of x to the power of y
- print() :: Prints to the standard output device
- property() :: Gets, sets, deletes a property
- range() :: Returns a sequence of numbers, starting from 0 and increments by 1 (by default)
- repr() :: Returns a readable version of an object
- reversed() :: Returns a reversed iterator
- round() :: Rounds a numbers
- set() :: Returns a new set object
- setattr() :: Sets an attribute (property/method) of an object
- slice() :: Returns a slice object
- sorted() :: Returns a sorted list
- @staticmethod() :: Converts a method into a static method
- str() :: Returns a string object
- sum() :: Sums the items of an iterator
- super() :: Returns an object that represents the parent class
- tuple() :: Returns a tuple
- type() :: Returns the type of an object
- vars() :: Returns the __dict__ property of an object
- zip() :: Returns an iterator, from two or more iterators

** Filter
The filter function will only return a list that returns *True* in a function's
condition statement.
#+BEGIN_SRC python
def check_even(num):
    return num%2 == 0
mynums = [1,2,3,4,5,6]
list(filter(check_even,mynums))

# or use a for iterate
for n in filter(check_even,mynums):
    print(n)
#+END_SRC

** Map
Map would expect a function to work
#+BEGIN_SRC python
def square(num):
    return num**2

my_nums = [1,2,3,4,5]

for item in map(square,my_nums):
    print(item)

# if you want the list bck
list(map(square,my_nums))
#+END_SRC

Another example using strings
#+BEGIN_SRC python
def splicer(mystring):
    if len(mystring)%2 == 0:
        return 'EVEN'
    else:
        return mystring[0]

names = ['Andy', 'Eve', 'Sally']

list(map(splicer,names))
#+END_SRC

** Type
Returns type of object
#+BEGIN_SRC python
string = "hello"
type(string)
#+END_SRC

#+begin_src python
<class 'str'>
#+end_src

** File Handling
- References :: [[https://docs.python.org/3/library/functions.html#open][open references]]

*** File Methods
- close() :: Closes the file
- detach() :: Returns the separated raw stream from the buffer
- fileno() :: Returns a number that represents the stream, from the operating system's perspective
- flush() :: Flushes the internal buffer
- isatty() :: Returns whether the file stream is interactive or not
- read() :: Returns the file content
- readable() :: Returns whether the file stream can be read or not
- readline() :: Returns one line from the file
- readlines() :: Returns a list of lines from the file
- seek() :: Change the file position
- seekable() :: Returns whether the file allows us to change the file position
- tell() :: Returns the current file position
- truncate() :: Resizes the file to a specified size
- writable() :: Returns whether the file can be written to or not
- write() :: Writes the specified string to the file
- writelines() :: Writes a list of strings to the file

*** Reading Files

**** Reading an entire file
#+begin_src python :results code
infile = "test.txt"

with open(infile) as text:
    return(text.read().strip())
#+end_src

#+RESULTS:
#+begin_src python
Example Data
For some intersting results

Check out the new blog site

Factual checking...
#+end_src

#+begin_src python
Example Data
For some intersting results

Check out the new blog site

Factual checking...
#+end_src

**** Reading one line at a time
#+begin_src python :results code
infile = "test.txt"

with open(infile) as text:
    return(text.readline())
    text.close()
#+end_src

#+begin_src python
Example Data
#+end_src

**** Read line by line
#+begin_src python :results code
infile = "test.txt"

with open(infile) as text:
    return(text.readlines())
#+end_src

#+begin_src python
['Example Data\n', 'For some intersting results\n', '\n', 'Check out the new blog site\n', '\n', 'Factual checking...\n']
#+end_src

** While loop to continue prompting for data until answered 'no'
#+begin_src python
def to_seconds(hours, minutes, seconds):
    return hours*3600+minutes*60+seconds

print("Welcome to the time converter")

cont = "y"

while(cont.lower() == 'y'):
    hours = int(input("Enter the number of hours: "))
    minutes = int(input("Enter the number of minutes: "))
    seconds = int(input("Enter the number of seconds: "))

    print("That's {} seconds".format(to_seconds(hours, minutes, seconds)))
    print()
    cont = input("Do you want to do another conversion? (y to continue) ")

print("Good bye!")
#+end_src
* Error Handling

** assertions
An assertion is a sanity-check that you can turn on or turn off when you have
finished testing the program. An expression is tested, and if the result comes
up false, an exception is raised. Assertions are carried out through use of the
assert statement.

#+BEGIN_SRC python
print(1)
assert 2 + 2 == 4
print(2)
assert 1 + 1 == 3
print(3)

# Results
>>>
1
2
AssertionError
>>>
#+END_SRC

Assertions can take more than one argument, so for instance you can run
something like this: ~assert(temp >= 0), "Colder than absolute zero!"~.

TODO read up more on assertions and get a better understanding of them

*** Using raise to call an exception
You can use raise as a way to call an exception.
#+BEGIN_SRC python
print(1)
raise ValueError
print(2)
#+END_SRC

*** Try Exceptions for Python
The *try* block contains code that may throw an exception, if it does not, then
the code in the *try:* block, otherwise if an exception occurrs, the code in the
*exception name:* is ran instead. There can also be multiple exception blocks, to
handle different exceptions. Alternatively, you can specify a generic *exception:*
which doesn't call the exception type, and if any exceptions occurr it'll catch
and return output from the exception block. This should be treated carefully as
it can mask programming mistakes.

#+BEGIN_SRC python
try:
   num1 = 7
   num2 = 0
   print (num1 / num2)
   print("Done calculation")
except ZeroDivisionError:
   print("An error occurred")
   print("due to zero division")
except (ValueError, TypeError):
   print("Error Occurred")
#+END_SRC

To ensure a piece of code regardless if there's an exception or not, you can use
the *final:* block. It should be noted, that if an exception is encountered in the
except: block, it'll throw an additional exception.

*** Python Exceptions & Files
Exceptions are errors when the compiler evaluates the code in your python file,
which can be due to a number of reasons. For one example, a multiplication of *7
x 0* would throw an exception *ZeroDivisionError: division by zero*.
** try except
The code in the *except* block is only executed if one of the instructions inside
of your try block raises an error of the matching type. *NOTE*: assert will get
removed if we ask our interpreter to optimize the code for performance.
#+begin_src python
def validate_user(username, minlen):
    assert type(username) == str, "username must be a string"
    if minlen < 1:
        raise ValueError("minlen must be at least 1")
    if len(username) < minlen:
        return False
    if not username.isalnum():
        return False
    return True

validate_user("", -1)
#+end_src

#+begin_src python
# minlen must be at least 1
#+end_src

* Modules
Modules are pieces of code that other people have written to fulfill common
tasks, such as generating random numbers, performing mathematical operations,
etc. The basic way to use a module is to add ~import module_name~ at the top of
your code, and then using module_name.var to access functions and values with
the name var in the module. For example, the following example uses the random
module to generate random numbers:
#+BEGIN_SRC python
import random
from math import pi
from math import sqrt as square_root

for i in range(5):
   value = random.randint(1, 6)
   print(value)
#+END_SRC

There are three main types of modules in Python, those you write yourself, those
you install from external sources, and those that are preinstalled with Python.

The last type is called the standard library, and contains many useful modules.
Some of the standard library's useful modules include:
- string
- re
- datetime
- math
- random
- os
- multiprocessing
- subprocess
- socket
- email
- json
- doctest
- unittest
- pdb
- argparse and sys

Tasks that can be done by the standard library include string parsing, data
serialization, testing, debugging and manipulating dates, emails, command line
arguments, and much more!

** Importing modules
Import by typing out *import /modulename/ [ as /alias/ ]*. Some things to keep in
mind:
1. Case sensitive
2. Anything in italics is a placeholder for specific information that you'll
   supply in your own code.
3. Anything in square brackets is optional
4. Never type the square brackets in your code

#+BEGIN_EXAMPLE
import csv as csvproc
#+END_EXAMPLE

#+BEGIN_EXAMPLE
import csv
#+END_EXAMPLE

** csv

*** reading csv file
#+begin_src python :results code
import csv
f = open("test.csv")
csv_f = csv.reader(f)
for row in csv_f:
    name, phone, role = row
    return("Name: {}, Phone: {}, Role: {}".format(name, phone, role))
f.close()
#+end_src

#+begin_src python
Name: Name: Sabrina Green, Phone:  Phone: 802-867-5309, Role:  Role: System Administrator
#+end_src

*** generating csv file
#+begin_src python
hosts = [["workstation.local", "192.168.25.46"], ["webserver.cloud", "10.2.5.6"]]
with open("hosts.csv", 'w') as hosts_csv:
    writer = csv.writer(hosts_csv)
    writer.writerows(hosts)
#+end_src

*** reading csv files with dictionaries
#+begin_src python
with open('test.csv') as software:
    reader = csv.DictReader(software)
    for row in reader:
        print(("{} has {} users").format(row["name"], row["users"]))
#+end_src

*** creating csv files from dictionaries
#+begin_example
import csv
users = [ {"name": "Sol Mansi", "username": "solm", "department": "IT Infrastructure"},
         {"name": "Charlie Grey", "username": "greyc", "department": "Development"}]
keys = ["name", "username", "department"]

with open('by_department.csv', 'w') as by_department:
    writer = csv.DictWriter(by_department, fieldnames=keys)
    writer.writeheader()
    writer.writerows(users)
#+end_example

** os

*** File exist
#+begin_src python :results code
import os
os.path.exists("test.txt")
#+end_src

#+begin_src python
True
#+end_src
*** Get ENV variables
The second blank ~""~ will tell the ~get~ function to return a blank string if it
fails to find the variable.
#+begin_src python :results code
import os
print("HOME:  " + os.environ.get("HOME", ""))
#+end_src

#+begin_src python
HOME:  /home/nick
#+end_src

*** os functions
- chdir() :: to change the directory.
- getcwd() :: returns the current working directory(CWD) in which the user is currently.
- listdir() :: It returns a list of files and the folders in the current directory.
- mkdir() ::
- makedirs() ::
- rmdir() ::
- removedirs() ::
- remove() ::
- rename() ::
- system() :: executing a shell command.
- popen() :: os.popen(command[, mode[, bufsize]]) : it opens a pipe to or from command. It returns an open file object connected to the pipe, which can be read or written depending on whether the mode is ‘r’ (default) or ‘w’.
- close() :: Close file descriptor fd.
- walk() :: it is a generator that yields a couple of three values as it is walking the directory tree and for each directory that it traverses and produces the directory path, the direct within that path and the files within that path. It is useful to keep track of all the directories.
- os.getgid(), os.getuid(), os.getpid(), and os.stat(): getgid() :: returns the real group id for the current process. The getuid() function returns the current process’s user id and getpid() returns real process id of the current process. The os.stat() function returns the list of details about the file or the directory name given in the argument.
- error :: It is environment error class for I/O errors and OSError and is raised when any function returns any system-related error. Each of the or module functions returns these errors when any invalid or inaccessible file is triggered in the line-of-code.
- stat() ::
- name :: This is the name of the imported operating system dependent module. Some of the registered module are – ‘posix’, ‘nt’, ‘os2’, ‘ce’, ‘java’ and ‘riscos’.
- environ :: It is known as the value of an object which returns all the directories of all user environment variables .E.g. ‘HOME’-directory environment variables
** os + subprocess
*** Modifying ENV variables leaving original intact
#+begin_src python
import os
import subprocess

my_env =  os.environ.copy()
my_env["PATH"] = os.pathsep.join(["/opt/myapp/", my_env["PATH"]])
# Here, the .join method is joining the additional path to, the 2nd argument
# which is my_env["PATH"]

result = subprocess.run(["myapp"], env=my_env)
#+end_src

** os + re

*** Move Files
#+BEGIN_SRC python
#!/usr/bin/env python
import os
import re

fname = input('Enter filename: ')
fh = open(fname)
fh_read = fh.readlines()

folder = os.listdir('./')
files2 = [f for f in os.listdir("./") if os.path.isfile(f)]

# Create the needed directories
for tf in fh_read:
    command = 'mkdir -p %s'%(tf)
    os.system(command)

# Move files to their respective folders
for files in files2:
    for tags in fh_read:
        pattern = re.findall(tags.rstrip(),files)
        if pattern:
            command = 'mv "%s" %s'%(files,tags)
            os.system(command)
#+END_SRC

*** Apply command from lists in file
#+BEGIN_SRC python
#!/usr/bin/env python
import os
import re

fname = input('File with list of tags: ')
if (len(fname) < 1):
    fname = 'test.txt'
fh = open(fname)
fh_read = fh.readlines()
folder = os.listdir('./')

for files in folder:
    for tags in fh_read:
        pattern = re.findall(tags.rstrip(),files)
        if pattern:
            command = 'iptc "%s" -a Keywords -v "%s" '%(files,tags)
            os.system(command)
#+END_SRC

** re

*** Basics

**** easy searching
The r in re.search(~r~"aza", "plaza") tell python to treat the string raw. This means python shouldn't try to interpret any special characters. It's a good idea to *always* use rawstrings in python.
#+begin_src python :results code
import re
result = re.search(r"aza", "plaza")
return(result)
#+end_src

#+begin_src python
<re.Match object; span=(2, 5), match='aza'>
#+end_src

**** ignore cases
#+begin_src python :results code
import re
result = re.search(r"aza", "plaza")
print(result, re.IGNORECASE)
#+end_src

#+begin_src python
None
#+end_src

**** passing special characters
#+begin_src python :results code
import re
print(re.search(r"[a-z]way", "End of highway"))
#+end_src

#+begin_src python
<re.Match object; span=(10, 14), match='hway'>
#+end_src

**** matching whole words
#+begin_src python :results code
import re
print(re.search(r"Py.+n", "Python"))
#+end_src

#+begin_src python
<re.Match object; span=(0, 6), match='Python'>
#+end_src

**** escaping characters
#+begin_src python :results code
import re
print(re.search(r"Pi\.", "Pi."))
#+end_src

#+begin_src python
<re.Match object; span=(0, 3), match='Pi.'>
#+end_src

*** Cheatsheet

**** Regular Expression Basics
- . :: Any character except newline
- a :: The character a
- ab :: The string ab
- a|b :: a or b
- a :: 0 or more a's
- \ :: Escapes a special character

**** Regular Expression Quantifiers
- * :: 0 or more
- + :: 1 or more
- ? :: 0 or 1
- {2} :: Exactly 2
- {2, 5} :: Between 2 and 5
- {2,} :: 2 or more
- (,5} :: Up to 5
Default is greedy. Append ? for reluctant.

**** Regular Expression Groups
- (...) :: Capturing group
- (?P<Y>...) :: Capturing group named Y
- (?:...) :: Non-capturing group
- \Y :: Match the Y'th captured group
- (?P=Y) :: Match the named group Y
- (?#...) :: Comment

**** Regular Expression Character Classes
- [ab-d] :: One character of: a, b, c, d
- [^ab-d] :: One character except: a, b, c, d
- [\b] :: Backspace character
- \d :: One digit
- \D :: One non-digit
- \s :: One whitespace
- \S :: One non-whitespace
- \w :: One word character
- \W :: One non-word character

**** Regular Expression Assertions
- ^ :: Start of string
- \A :: Start of string, ignores m flag
- $ :: End of string
- \Z :: End of string, ignores m flag
- \b :: Word boundary
- \B :: Non-word boundary
- (?=...) :: Positive lookahead
- (?!...) :: Negative lookahead
- (?<=...) :: Positive lookbehind
- (?<!...) :: Negative lookbehind
- (?()|) :: Conditional

**** Regular Expression Flags
- i :: Ignore case
- m :: ^ and $ match start and end of line
- s :: . matches newline as well
- x :: Allow spaces and comments
- L :: Locale character classes
- u :: Unicode character classes
- (?iLmsux) :: Set flags within regex

**** Regular Expression Special Characters
- \n :: Newline
- \r :: Carriage return
- \t :: Tab
- \YYY :: Octal character YYY
- \xYY :: Hexadecimal character YY

**** Regular Expression Replacement
- \g<0> :: Insert entire match
- \g<Y> :: Insert match Y (name or number)
- \Y :: Insert group numbered Y

** re + sys
*** Using regex to parse logfile
#+begin_src python
import sys
import re

logfile = sys.argv[1]

with open(logfile) as f:
    for line in f:
        if "CRON" not in line:
            continue
        pattern = r"USER \((\w+)\)$"
        result = re.search(pattern, line)
        print(result[1])
#+end_src

And this will provide a count of our users
#+begin_src python
import re
import sys

logfile = sys.argv[1]
usernames = {}

with open(logfile) as f:
    for line in f:
        if "CRON" not in line:
            continue
        pattern = r"USER \((\w+)\)$"
        result = re.search(pattern, line)
        if result is None:
            continue
        name = result[1]
        usernames[name] = usernames.get(name, 0) + 1
print(usernames)
#+end_src
** subprocess

*** Running system commands
#+begin_src python :results code
import subprocess
subprocess.run(["date"])
#+end_src

#+begin_src python
CompletedProcess(args=['date'], returncode=0)
#+end_src

And then to pass arguments:
#+begin_src python :results code
import subprocess
subprocess.run(["sleep", "2"])
#+end_src

#+begin_src python
CompletedProcess(args=['sleep', '2'], returncode=0)
#+end_src

Getting return codes:
#+begin_src python :results code
import subprocess
result = subprocess.run(["ls", "this_file_does_not_exist"])
return(result.returncode)
#+end_src

#+begin_src python
2
#+end_src

*** Getting output from a command
#+begin_src python
import subprocess
result = subprocess.run(["host", "8.8.8.8"]), capture_output=True)ii
print(result.returncode)
# 0
print(result.stdout)
# b'8.8.8.8.in-addr.arpa domain name pointer dns.google.\n'
# Essentially the *b* at the start indicates python is treating the result as byte
# encoding. Because it doesn't really know what to treat it as, but to change this
# you'll need to tell Python to encode in say, UTF-8 encoding.
print(result.stdout.decode().split())
# ['8.8.8.8.in-addr.arpa', 'domain', 'name', 'pointer', 'dns.google']

result = subprocess.run(["rm", "does_not_exist"], capture_output=True)
print(result.stderr.decode())
#+end_src

Essentially the *b* at the start indicates python is treating the result as byte
encoding. Because it doesn't really know what to treat it as, but to change this
you'll need to tell Python to encode in say, UTF-8 encoding.

** sys

*** passing parameters
#+begin_src python
#!/usr/bin/env python3
import sys
print(sys.argv)

# $./parameters.py one two three
['./parameters.py', 'one', 'two', 'three']
#+end_src

*** exit status
#+begin_src shell
echo $? # returns last exit status
#+end_src

#+begin_src shell
wc something.py
# wc: something.py: No such file or directory
echo $?
1
#+end_src

#+begin_src python
import os
import sys

filename=sys.argv[1]

if not os.path.exists(filename):
    with open(filename, "w") as f:
        f.write("New file created\n")
else:
    print("Error, the file {} already exists!".format(filename))
    sys.exit(1)
#+end_src
** unittest
*** something
#+begin_src python
from rearrange import rearrange_name
import unittest

class TestRearrange(unittest.TestCase):
    def test_basic(self):
        testcase = "Lovelace, Ada"
        expected = "Ada Lovelace"
        self.assertEqual(rearrange_name(testcase), expected)

    def test_empty(self):
        testcase = ""
        expected = ""
        self.assertEqual(rearrange_name(testcase), expected)

unittest.main()
#+end_src
* Testing
Ability to test and validate code works as intended.

** Unit Tests
Testing a small piece of code. For example, let's say we have a function called
~rearrange.py~ and inside it the ~rearrange_name~ function.
#+begin_src python
from rearrange import rearrange_name
rearrange_name("Lovelace", "Ada")
'Ada Lovelace'
#+end_src
* Extras
** Signaling to a process
Signaling let's us trigger a process to stop, for instance ~CTRL+C~ at the shell
will terminate a process.

- This is known as the ~SIGINT~ signal which performs a clean termination.
- The ~SIGSTOP~ signal, which is ~CTRL+Z~ will cause the process to stop without actualy terminating it.
- Another signal, which is ~SIGTERM~, will cause the process to terminate.
** Steps to writing a script or program
1. Understand the problem statement
2. Research
3. Planning
