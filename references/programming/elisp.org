#+TITLE: Elisp

* INTRODUCTION
** List Processing
*** Lisp Lists
A list in Elisp looks like this ~'(rose violet daisy buttercup)~, the list is
enclosed in parentheses, and seperated by whitespace.

**** Numbers in Lists
Numbers can also be passed in lists, just like strings. ~(+ 2 2)~

**** Lists inside Lists
You can also define lists inside of another list ~'(this list has (a list inside
of it))~

**** Lisp Atoms
_In my own words_: Atoms make up a words, each atom is seperated by whitespace and
enclosed in paraenthesis, strings inside double quotes are treated as a single
atom.

Words in Elisp are called _atoms_, the term comes from the historical meaning of
the word atom, which means "indivisible". See Elisp Words.

: (setq my-list '(this list includes "text between quotation marks"))

Technically speaking, a list in Lisp consists of parentheses surrounding atoms
separated by whitespace or surrounding other lists or surrounding both atoms and
other lists. A list can have just one atom in it or have nothing in it at all.
The Printed Representation of both atoms and lists are called symbolic
expressions, or more precisely, s-expressions. Words inside double quotes, are
treated as an atom. Such as:

**** Whitespace in Lists
Whitespace does not really matter, except maybe if it's in double quotes.
Otherwise, whitespace will seperate your atoms.

*** Run a Program
Evaluating a list, even if the list are a bunch of _atoms_ is running a program,
to evaluate and return that list. The single quote =`= infront of a list tells the
Elisp interpreter to do nothing, other than take it as it is written. See
Evaluation.

*** Making Errors
Causing an error will generate a backtrace with some debugging details as to why
the evaluation failed to run the program.
#+BEGIN_EXAMPLE
     ---------- Buffer: *Backtrace* ----------
     Debugger entered--Lisp error: (void-function this)
       (this is an unquoted list)
       eval((this is an unquoted list) nil)
       elisp--eval-last-sexp(nil)
       eval-last-sexp(nil)
       funcall-interactively(eval-last-sexp nil)
       call-interactively(eval-last-sexp nil nil)
       command-execute(eval-last-sexp)
     ---------- Buffer: *Backtrace* ----------
#+END_EXAMPLE
*** Names & Definitions
The names of functions (also called symbols), are not the instructions in itself, but a means of the Elisp interpreter to look up those instructions. So you could very well have two lists, defined by the same symbol, called in two different areas of a function and behave entirely different. The Elisp interpreter will simply run through the list, executing each list one at a time, and evaluate the results. Becaues of this, the symbol can only have one definition tied to it at a time.
*** Lisp Interpreter
Some important things to remember, is how the interpreter reads, and what things it looks for when evaluating a list:
1. Is there a single quote in-front of the list? if so _evaluate as its written_
2. Otherwise, check the first atom in the list, and do a look-up for a function by its name, if so it carries out its instructions.
3. If both of these fail, it returns an _error_

**** Complications
1. The first complication, the interpreter can evaluate a symbol that is not quoted and does not have parenthesis around it, Elisp will try and interpret it as a variable and return its value. This is described more in the Variables section. See Elisp Words.
2. The second complication, some functions that are called _special forms_, can cause this type of issue, for example like the one used to define a new function. See Elisp Words.
3. Lastly, there are also what is called _macros_. A macro is a construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression that is to be evaluated in plaec of hte original expression. See Lisp Macro.
4. Last complication, if there is a list inside of the outer list, it'll work on the inner list first.

**** Byte Compiling
One other aspect of interpreting: the Lisp interpreter is able to interpret two kinds of entity: humanly readable code, on which we will focus exclusively, and specially processed code, called byte compiled code, which is not humanly readable. Byte compiled code runs faster than humanly readable code.

You can transform humanly readable code into byte compiled code by running one of the compile commands such as ~byte-compile-file~. Byte compiled code is usually stored in a file that ends with a .elc extension rather than a .el extension. You will see both kinds of file in the emacs/lisp directory; the files to read are those with .el extensions.

Check out Byte Compilation in the Elisp References Manual.
*** Evaluation
:PROPERTIES:
:ID:       da49f021-ea2c-482a-8b93-4eafbfc3955f
:END:
When the Lisp Interpreter works, or runs an expression, the term for the activity is called _evaluation_. We say that the interpreter _evaluates the expression_.

**** How the Lisp Interpreter Acts
After evaluating an expression, the Lisp interpreter will most likely return the value that the computer produces by carrying out the instructions it found in the function definition, or perhaps it will give up on that function and produce an error message. (The interpreter may also find itself tossed, so to speak, to a different function or it may attempt to repeat continually what it is doing for ever and ever in an infinite loop. These actions are less common; and we can ignore them.) Most frequently, the interpreter returns a value.

At the same time the interpreter returns a value, it may do something else as well, such as *move a cursor* or *copy a file*; this other kind of action is called a _side effect_. Actions that we humans think are important, such as *printing results*, are often _side effects_ to the Lisp interpreter. It is fairly easy to learn to use _side effects_.

**** Evaluating Inner Lists
Outer lists may rely or use the values returned from inner lists, which is why inner lists are processed first.
*** Variables
:PROPERTIES:
:ID:       bccf02f4-1e45-43da-91ef-2e570cb0b67f
:END:
In Elisp, a variable will basically store a value attached to a symbol, just as a function with instructions can be attached to a symbol.

**** ~fill-column~ example
Fill Column is a variable that's used by emacs, to use the value it returns, as the column number that buffers will use when wrapping text. To set *values* to a ~symbol~, you can take a look at set & setq..

**** Void Function
When we evaluate ~fill-column~, we don't have to surround the _symbol name_ in parenthesis because we only need it to return the value of the variable, and did not intend it to run a function. If we had put ~fill-column~ in parenthesis, the Lisp Interpreter would try to find the corresponding function, but would fail and return a _backtrace_ error for *void function*.

**** Void Variable
This is similar to the Void Function, but if we try to evaluate a function as a variable, we'll get a _backtrace_ error for *void variable* because that variable does not exist.

*** Arguments
Just as you would think, arguments are what's passed to a function to perform the operation. Such as ~(+ 2 2)~ your arguments would be your 2's and your =+= is your symbol that looks up the function for the add operation. There are different data types that can be used as arguments to pass to your functions. Such as *add*, *concat*, *substring* and *arguments with lists*.

Arguments are defined in defun as such =(defun new-func-name (arg))=
**** Data Types
*Data types* are a list of possible objects. Every object belongs to at-least one *type*.
**** Operations
=Operations= performs a mathematical formula on your arguments, for example: =(+ 2 2)= will output =4=.
**** Concat
=Concat= would be used to link together two or more strings. For example =(concat "abc" "def")= would read back as ="abcdef"=.
**** Substring
=substring= takes a string and numbers, the string is the first argument, the two numbers dictate what in the string will get outputted. For example =(substring "The quick brown fox jumped." 16 19)= would output =fox=.
**** Arguments with Lists
Takes lists and passes them through as arguments
#+BEGIN_SRC emacs-lisp
(+ 2 fill-column)
(concat "The " (number-to-string (+ 2 fill-column)) " red foxes.")
#+END_SRC
**** Message Argument
Basically, you can pass output from a symbol to a function with =%s= or =%d=

#+BEGIN_SRC emacs-lisp
(message "The name of this buffer is: %s." (buffer-name))
(message "The name of this buffer is: %d." fill-column)
(message "He saw %d %s"
         (- fill-column 32)
         (concat "red "
                 (substring
                  "The quick brown foxes jumped." 16 21)
                 " leaping."))
#+END_SRC

**** Wrong Argument Type
If you pass the wrong argument type, you can expect this from Backtrace: =(wrong-type-argument number-or-marker-p hello)=
*** ~set~ & ~setq~
:PROPERTIES:
:ID:       6e5ad639-c0d0-4f83-b144-f6a4db98fa4d
:END:
There are two methods to assigning variables to a symbol, one is by using =set= or =setq= and the other is by using =let=.

**** Using ~set~
*set* is an older funciton and not used too often anymore, but it does much of the same thing that ~setq~ does. ~set~ does not quote the variable, so to specify a new variable you'll have to:
: (set 'carnivor '(lizard alligator))

**** ~setq~ is the preferred method
The big difference between ~set~ and ~setq~ is that ~setq~ will quote your symbol for you, so you don't have to.
: (set carnivor '(lizard alligator))
** Practicing Evaluation
Evaluation is in other words, how you can run and execute the symbol, rather it be a set of instructions or variable. And if you want a function to be interactive, or in other words, be callable as a command, then you need to add ~(interactive)~ to the function.
** Writing Defuns
*** Primitive Functions
Primitive functions in Elisp, are basically some of the original source code that built with ~C~ to get the basics of Emacs to work. These are some of the oldest building blocks.
*** Defun Function
Defun is the macro used to build new functions, it has 5 basic principles.
1. The name of the symbol to which the function definition should be attached.
2. A list of the arguments that will be passed to the function. If no arguments will be passed to the function, this is an empty list, ().
3. Documentation describing the function. (Technically optional, but strongly recommended.)
4. Optionally, an expression to make the function interactive so you can use it by typing M-x and then the name of the function; or by typing an appropriate key or keychord.
5. The code that instructs the computer what to do: the body of the function definition.

#+BEGIN_EXAMPLE
(defun $1 ($2)
 "$3"
 (interactive "$4")
 ($5))
#+END_EXAMPLE
*** Installing a function
Just evaluate the function and this will install it, but in that session, and if you reboot emacs, the function is lost. To permanently install the function, add it to your private config or better yet, specify emacs to load the file. All files should end with the extension =.el=.
*** Interactive
You make a function interactive by adding ~(interactive)~ to the function, and if you want to be able to pass a numericale number by holding *<META>* and a number, then use ~(interactive "p")~.
*** let
Is used to attach or bind a Symbols to a Value in such a way that the elisp interpreter will not confuse the variable with a variable of the same name that is not part of the function. Another way to look at it, let is like setq but only temporary.

One other key point, variables defined inside of let are temporary and only stored in that function. So your actions will need to utilize those variables in the body, otherwise they will not exist.

#+caption: More than one variable defined
#+BEGIN_SRC emacs-lisp
(let ((my-test-variable "Value")
      (my-second-test-variable "Data"))
  (message "%s %s" my-test-variable my-second-test-variable))
#+END_SRC
*** if
Basically allows elisp to make a decision. The basics of an ~if~ symbol are
- If a condition = *TRUE* execute code
- If a condition = *FALSE* then do nothing

Another quick note on ~if~, is that you can run a if then else condition by specifying the actions after your true statement.
#+BEGIN_SRC emacs-lisp
(if (> 1 2)
    (message "Great than") ; True execute this code
  (message "Less than")) ; False execute this code
#+END_SRC
*** else
This is pretty much the same as ~if~ except, you write a new line of code after the initial one.
#+BEGIN_EXAMPLE
     (if (> 4 5)                               ; if-part
         (message "4 falsely greater than 5!") ; then-part
       (message "4 is not greater than 5!"))   ; else-part
#+END_EXAMPLE
*** save-excursion
This function saves the location of ~point~, executes the function and then returns to ~point~.
** Buffer Walkthrough
** More Complex
*** copy-to-buffer :function:
#+BEGIN_SRC emacs-lisp
(interactive "BCopy to buffer: \nr")
(let ((oldbuf (current-buffer)))
  (with-current-buffer (get-buffer-create buffer)
    (barf-if-buffer-read-only)
    (erase-buffer)
    (save-excursion
      (insert-buffer-substring oldbuf start end))))
#+END_SRC
*** insert-buffer :function:
- Here is the older code
  #+BEGIN_SRC emacs-lisp
(defun insert-buffer (buffer)
  "Insert after point the contents of BUFFER.
     Puts mark after the inserted text.
     BUFFER may be a buffer or a buffer name."
  (interactive "*bInsert buffer: ")
  (or (bufferp buffer)
      (setq buffer (get-buffer buffer)))
  (let (start end newmark)
    (save-excursion
      (save-excursion
        (set-buffer buffer)
        (setq start (point-min) end (point-max)))
      (insert-buffer-substring buffer start end)
      (setq newmark (point)))
    (push-mark newmark)))
  #+END_SRC
- =(interactive "*bInsert buffer: ")=
  - The =*= looks to see if the buffer is read-only? But how? It'll essentially print a message to the echo area.
  - The lowercase =b= tells emacs the function insert-buffer should be an existing buffer or else it's name.
  - [ ] How does =*= work for interactive?
**** or
It can have any number of arguments, and it returns the first value of the argument that is not =nil=
#+BEGIN_SRC emacs-lisp
(or (bufferp buffer)
    (setq buffer (get-buffer buffer)))
#+END_SRC
**** let
#+BEGIN_SRC emacs-lisp
(save-excursion
  (set-buffer buffer)
  (setq start (point-min) end (point-max)))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(let (start end newmark)
  (save-excursion
    (save-excursion
      (set-buffer buffer)
      (setq start (point-min) end (point-max)))
    (insert-buffer-substring buffer start end)
    (setq newmark (point)))
  (push-mark newmark))
#+END_SRC
*** beginning-of-buffer :function:
#+BEGIN_SRC emacs-lisp
(defun beginning-of-buffer (&optional arg)
  "documentation..."
  (interactive "P")
  (or (is-the-argument-a-cons-cell arg)
      (and are-both-transient-mark-mode-and-mark-active-true)
      (push-mark))
  (let (determine-size-and-set-it)
    (goto-char
     (if-there-is-an-argument
      figure-out-where-to-go
      else-go-to
      (point-min))))
#+END_SRC
#+BEGIN_SRC emacs-lisp
(if (> (buffer-size) 10000)
    ;; Avoid overflow for large buffer sizes!
    (* (prefix-numeric-value arg)
       (/ size 10))
  (/
   (+ 10
      (*
       size (prefix-numeric-value arg))) 10)))
#+END_SRC
*** Review
Symbols to make note of
**** or :function:
Return the value of the first argument that is not nil
**** and :function:
If none of the arguments return nil, return value of the last argument. Otherwise, return nil.
**** &optional :function:
Argument is optional such as =(defun symbol (&optional arg))=
**** prefix-numeric-value :function:
Convert the raw prefix argument produced by =(interactive "P")= to a numeric value.
**** forward-line :function:
As it sounds, move point to the beginning of the next line, or if the argument is greater than 1, forward that many lines.
**** erase-buffer :function:
Delete teh entire contents of the current buffer
**** bufferp :function:
Return =t= if its arguemnt is a buffer, otherwise return nil.
** Narrowing & Widening
Narrowing will allow you to narrow the buffer contents to the headline selected, and its subtrees. While widening will return the buffer to show all content.

*** save-excursion
Is a function that allows you to widen a buffer temporarily, to run or execute the set of instructions in the funtion, and then return the buffer to its original narrowed state.
** car, cdr and cons
In Lisp, ~car~, ~cdr~, and ~cons~ are *fundamental functions*. The cons function is used to *construct lists*, and the car and cdr functions are used to *take them apart*. In the walk through of the copy-region-as-kill function, we will see cons as well as two variants on cdr, namely, setcdr and nthcdr. (See copy-region-as-kill.)
1. =cons= is used to construct lists, and the =car= and =cdr= functions take them apart.
2. =cons= is the short word for *construct*

*** copy-region-as-kill
#+BEGIN_SRC emacs-lisp
(defun copy-region-as-kill (beg end)
  "Save the region as if killed, but don't kill it.
     In Transient Mark mode, deactivate the mark.
     If `interprogram-cut-function' is non-nil, also save the text for a window
     system cut and paste."
  (interactive "r")
  (if (eq last-command 'kill-region)
      (kill-append (filter-buffer-substring beg end) (< end beg))
    (kill-new (filter-buffer-substring beg end)))
  (if transient-mark-mode
      (setq deactivate-mark t))
  nil)
#+END_SRC

*** car and cdr

~car~ simply gives you the first object in a list - *note:* after =car= is ran, the list remains the same.

#+BEGIN_SRC emacs-lisp
(car '(rose violet daisy buttercup))
#+END_SRC

~cdr~ will return the remaining items in a list

#+BEGIN_SRC emacs-lisp
(cdr '(rose violet daisy buttercup))
#+END_SRC

*** cons
This Function constructs Lists.

#+BEGIN_SRC emacs-lisp
(defvar wood-types 'pine)
(cons wood-types '(oak fir maple))
#+END_SRC

building a list
#+BEGIN_SRC emacs-lisp
(setq my-list '(buttercup))
(setq my-list (cons my-list '(more data coming)))
(length my-list)
(car my-list)
(cdr my-list)
#+END_SRC

*** nthcdr
- Similar to =cdr=, this will print the *integer* number in the slot number and everything after it.
  #+BEGIN_SRC emacs-lisp
(defvar my-list '(buttercup))
(setq my-list (cons my-list '(more data coming)))
(nthcdr 2 my-list)
  #+END_SRC

*** nth
- =nth= will return the value in it's slot, and nothing more.
  #+BEGIN_SRC emacs-lisp
(defvar my-list '(buttercup))
(setq my-list (cons my-list '(more data coming)))
(nth 2 my-list)
  #+END_SRC
*** setcar
- =setcar= will essentially replace the first value in your list.
  #+BEGIN_SRC emacs-lisp
(setq my-list '(buttercup data for reals))
(setcar my-list 'more)
(list my-list)
  #+END_SRC
*** setcdr
- =setcdr= will do the opposite, and replace the remaining values in your list with your new values.
  #+BEGIN_SRC emacs-lisp
(setq my-list '(buttercup data for reals))
(setcdr my-list '(get rich fast))
(list my-list)
  #+END_SRC
** Cutting & Storing Text
Whenever you cut or clip text out of a Buffer with a kill command in GNU Emacs, it is stored in a list and you can bring it back with a yank command. =kill= essentially cuts your text, and =killed= is competing the action.

*** storing text in list
The function =cons= can be used to construct a new list, such as

#+BEGIN_SRC emacs-lisp
(cons "another piece"
      '("a piece of text" "previous piece"))
#+END_SRC

#+RESULTS:
| another piece | a piece of text | previous piece |

#+BEGIN_SRC emacs-lisp
(car (nthcdr 1 '("another piece"
                 "a piece of text"
                 "more text to read")))
#+END_SRC

#+RESULTS:
: a piece of text

*** zap-to-char
#+BEGIN_SRC emacs-lisp
(defun zap-to-char (arg char)
  "Kill up to and including ARG'th occurrence of CHAR.
     Case is ignored if `case-fold-search' is non-nil in the current buffer.
     Goes backward if ARG is negative; error if CHAR not found."
  (interactive "p\ncZap to char: ")
  (if (char-table-p translation-table-for-input)
      (setq char (or (aref translation-table-for-input char) char)))
  (kill-region (point) (progn
                         (search-forward (char-to-string char)
                                         nil nil arg)
                         (point))))
#+END_SRC
- See interactive for more details on =p= and =c=
**** char-table-p
- Determined whether its argument is a character table. When it is, it passes the character to the function =zap-to-char=.
**** kill-region
- Kill 'cut' text between point and mark.
  #+BEGIN_EXAMPLE
(kill-region BEG END &optional REGION)
  #+END_EXAMPLE
**** aref
- Return the element of array at index IDX. Array may be a *vector*, *string*, *char-table*, *bool-vector*, a *record*, or a *byte-code* object.
**** char-to-string
=zap-to-char= uses the =search-forward= function, which requires a string to search and not a character. This is where =char-to-string= comes in handy by converting the *char* to a *string*.
**** progn
- =progn= is a special form that causes each of its arguments to be evaluated in sequence and then returns the value of the last one.
  #+BEGIN_SRC emacs-lisp
(progn 'BODY
       'Data)
  #+END_SRC
*** kill-region
Kill region cuts the text from the region and stored it in the kill ring.
#+BEGIN_EXAMPLE
     (defun kill-region (beg end)
       "Kill (\"cut\") text between point and mark.
     This deletes the text from the buffer and saves it in the kill ring.
     The command \\[yank] can retrieve it from there. ... "

       ;;  Since order matters, pass point first.
       (interactive (list (point) (mark)))
       ;;  And tell us if we cannot cut the text.
       ;; 'unless' is an 'if' without a then-part.
       (unless (and beg end)
         (error "The mark is not set now, so there is no region"))

       ;;  'condition-case' takes three arguments.
       ;;    If the first argument is nil, as it is here,
       ;;    information about the error signal is not
       ;;    stored for use by another function.
       (condition-case nil

           ;;  The second argument to 'condition-case' tells the
           ;;    Lisp interpreter what to do when all goes well.

           ;;    It starts with a 'let' function that extracts the string
           ;;    and tests whether it exists.  If so (that is what the
           ;;    'when' checks), it calls an 'if' function that determines
           ;;    whether the previous command was another call to
           ;;    'kill-region'; if it was, then the new text is appended to
           ;;    the previous text; if not, then a different function,
           ;;    'kill-new', is called.

           ;;    The 'kill-append' function concatenates the new string and
           ;;    the old.  The 'kill-new' function inserts text into a new
           ;;    item in the kill ring.

           ;;    'when' is an 'if' without an else-part.  The second 'when'
           ;;    again checks whether the current string exists; in
           ;;    addition, it checks whether the previous command was
           ;;    another call to 'kill-region'.  If one or the other
           ;;    condition is true, then it sets the current command to
           ;;    be 'kill-region'.
           (let ((string (filter-buffer-substring beg end t)))
             (when string                    ;STRING is nil if BEG = END
               ;; Add that string to the kill ring, one way or another.
               (if (eq last-command 'kill-region)
                   ;;    − 'yank-handler' is an optional argument to
                   ;;    'kill-region' that tells the 'kill-append' and
                   ;;    'kill-new' functions how deal with properties
                   ;;    added to the text, such as 'bold' or 'italics'.
                   (kill-append string (< end beg) yank-handler)
                 (kill-new string nil yank-handler)))
             (when (or string (eq last-command 'kill-region))
               (setq this-command 'kill-region))
             nil)

         ;;   The third argument to 'condition-case' tells the interpreter
         ;;    what to do with an error.
         ;;    The third argument has a conditions part and a body part.
         ;;    If the conditions are met (in this case,
         ;;             if text or buffer are read-only)
         ;;    then the body is executed.
         ;;    The first part of the third argument is the following:
         ((buffer-read-only text-read-only) ;; the if-part
          ;; ...  the then-part
          (copy-region-as-kill beg end)
          ;;    Next, also as part of the then-part, set this-command, so
          ;;    it will be set in an error
          (setq this-command 'kill-region)
          ;;    Finally, in the then-part, send a message if you may copy
          ;;    the text to the kill ring without signaling an error, but
          ;;    don't if you may not.
          (if kill-read-only-ok
              (progn (message "Read only text copied to kill ring") nil)
            (barf-if-buffer-read-only)
            ;; If the buffer isn't read-only, the text is.
            (signal 'text-read-only (list (current-buffer)))))
#+END_EXAMPLE
*** copy-region-as-kill

Copied a region of text from a buffer and (via either kill-append or kill-new) saves in the kill ring.

#+BEGIN_EXAMPLE
     (defun copy-region-as-kill (beg end)
       "Save the region as if killed, but don't kill it.
     In Transient Mark mode, deactivate the mark.
     If `interprogram-cut-function' is non-nil, also save the text for a window
     system cut and paste."
       (interactive "r")
       (if (eq last-command 'kill-region)
           (kill-append (filter-buffer-substring beg end) (< end beg))
         (kill-new (filter-buffer-substring beg end)))
       (if transient-mark-mode
           (setq deactivate-mark t))
       nil)
#+END_EXAMPLE
*** defvar
Define Variable, slightly different from ~setq~, in that ~defvar~ has a documentation string that's required and it will only assign the variable if there is not variable defined by the symbol's name.

While you can use ~defvar~ to create a variable, if you expect this to be customized by the user, its better to use ~defcustom~ instead so that it's accessible by the customization group.
*** setcdr

#+BEGIN_SRC emacs-lisp :results code :export t
(setq triple '(1 2 3))
(setcar triple '37)
(setcdr triple '("foo" "bar"))
(print triple)
#+END_SRC

#+RESULTS:
#+begin_src emacs-lisp
(37 "foo" "bar")
#+end_src
** List Implementation

*** Lists diagrammed
This will basically break-down the way lists are stored in computer memory to help visually describe how this works.

Evaluating the list ~(rose violet buttercup)~
#+BEGIN_EXAMPLE
         ___ ___      ___ ___      ___ ___
        |___|___|--> |___|___|--> |___|___|--> nil
          |            |            |
          |            |            |
           --> rose     --> violet   --> buttercup
#+END_EXAMPLE

Mean while, if we do ~(setq bouquet '(rose violet buttercup))~
#+BEGIN_EXAMPLE
     bouquet
          |
          |     ___ ___      ___ ___      ___ ___
           --> |___|___|--> |___|___|--> |___|___|--> nil
                 |            |            |
                 |            |            |
                  --> rose     --> violet   --> buttercup
#+END_EXAMPLE

In addition, when using ~cdr~ like such ~(setq flowers (cdr bouquet))~
#+BEGIN_EXAMPLE
     bouquet        flowers
       |              |
       |     ___ ___  |     ___ ___      ___ ___
        --> |   |   |  --> |   |   |    |   |   |
            |___|___|----> |___|___|--> |___|___|--> nil
              |              |            |
              |              |            |
               --> rose       --> violet   --> buttercup
#+END_EXAMPLE

The function ~cons~ adds a new pair of addresses to the front of a series of addresses like that shown above. For example, evaluating the expression ~(setq bouquet (cons 'lily bouquet))~
#+BEGIN_EXAMPLE
     bouquet                       flowers
       |                             |
       |     ___ ___        ___ ___  |     ___ ___       ___ ___
        --> |   |   |      |   |   |  --> |   |   |     |   |   |
            |___|___|----> |___|___|----> |___|___|---->|___|___|--> nil
              |              |              |             |
              |              |              |             |
               --> lily      --> rose       --> violet    --> buttercup
#+END_EXAMPLE
*** Symbols as a chest of drawers
Actually, what is put in each drawer is the address of the value or function definition. It is as if you found an old chest in the attic, and in one of its drawers you found a map giving you directions to where the buried treasure lies.

#+BEGIN_EXAMPLE
                 Chest of Drawers            Contents of Drawers

                 __   o0O0o   __
               /                 \
              ---------------------
             |    directions to    |            [map to]
             |     symbol name     |             bouquet
             |                     |
             +---------------------+
             |    directions to    |
             |  symbol definition  |             [none]
             |                     |
             +---------------------+
             |    directions to    |            [map to]
             |    variable value   |             (rose violet buttercup)
             |                     |
             +---------------------+
             |    directions to    |
             |    property list    |             [not described here]
             |                     |
             +---------------------+
             |/                   \|
#+END_EXAMPLE

** Yanking
Yank will paste the content from the ~kill-ring~. Similar to cut & paste.

*** ~kill-ring~
The kill ring is a list of strings like such \\
~("some text" "a different piece of text" "yet more text")~ \\

If you were to run the command ~yank~ you would end up pulling the first string from the list ~"some text"~ and so-on until the list was emptied. Generally there are 3 commands to pull text back which are ~yank~, ~yank-pop~ and ~rotate-yank-pointer~.

*** The ~kill-ring-yank-pointer~ Variable
Thus, if the value of the kill ring is: ~("some text" "a different piece of text" "yet more text")~ and the ~kill-ring-yank-pointer~ points to the second clause, the value of ~kill-ring-yank-pointer~ is: ~("a different piece of text" "yet more text")~
** Loops & Recursion
There are basically two loops, ~while~ and ~recursion~.

*** The ~while~ loop
While will run it's first symbol to determine if it returns *true* or *false*. If it returns *false*, then the rest of the /body/ is skipped. Otherwise if it returns *true* then the body is evaluated and then re-tests the first argument to see if it returns *true* or *false* until it eventually returns *false* and exits the function.

The one catch to this is the ~while~ loop will never return a *true* value if it runs the /body/. It'll always return ~nil~ or ~false~.

**** An example ~while~ loop that outputs a list and sets the value to ~cdr~
~(setq animals '(gazelle giraffe lion tiger))~ and then run
#+begin_src emacs-lisp
(defun while-list-print ()
 "WHILE loop is t return car output and set list to cdr"
 (while animals
  (print (car animals))
  (setq (cdr animals))))
#+end_src

**** Incrementing loop
You can use a counter to make a ~while~ loop eventually return *false* can help ensure the while loop exits.
#+begin_src emacs-lisp
set-count-to-initial-value
(while (< count desired-number)
  body...
  (setq count (1+ count)))
#+end_src

Another example
#+BEGIN_EXAMPLE
     (defun triangle (number-of-rows)
       "Add up the number of pebbles in a triangle.
     The first row has one pebble, the second row two pebbles,
     the third row three pebbles, and so on.
     The argument is NUMBER-OF-ROWS."
       (let ((total 0)
             (row-number 1))
         (while (<= row-number number-of-rows)
           (setq total (+ total row-number))
           (setq row-number (1+ row-number)))
         total))
#+END_EXAMPLE

*** ~dolist dotimes~
~dolist~ works like a ~while~ loop that cdrs down a list: dolist automatically shortens the list each time it loopstakes the cdr of the listand binds the car of each shorter version of the list to the first of its arguments.

~dotimes~ loops a specific number of times: you specify the number.

**** ~dolist~
The ~dolist~ expression does very much the same as the while expression, except that the dolist macro does some of the work you have to do when writing a while expression. For example, the dolist will automatically *shorten* the list for you.

And here is how you could use the dolist macro:
#+BEGIN_EXAMPLE
     (setq animals '(gazelle giraffe lion tiger))

     (defun reverse-list-with-dolist (list)
       "Using dolist, reverse the order of LIST."
       (let (value)  ; make sure list starts empty
         (dolist (element list value)
           (setq value (cons element value)))))

     (reverse-list-with-dolist animals)
#+END_EXAMPLE

**** ~dotimes~
The ~dotimes~ macro is similar to dolist, except that it loops a specific number of times.
#+BEGIN_EXAMPLE
     (defun triangle-using-dotimes (number-of-rows)
       "Using `dotimes', add up the number of pebbles in a triangle."
     (let ((total 0))  ; otherwise a total is a void variable
       (dotimes (number number-of-rows total)
         (setq total (+ total (1+ number))))))

     (triangle-using-dotimes 4)
#+END_EXAMPLE
*** TODO ~recursion~
A recursive function contains code that tells the Lisp interpreter to call a program that runs exactly like itself, but with slightly different arguments. The code runs exactly the same because it has the same name. However, even though the program has the same name, it is not the same entity. It is different. In the jargon, it is a different *“instance”*.

**** Building Robots: Extending the Metaphor
:PROPERTIES:
:ID:       64197c30-e071-469a-a326-4d6dc05ea050
:END:
It is sometimes helpful to think of a running program as a robot that does a job. In doing its job, a recursive function *calls on a second robot* to help it. The second robot is *identical* to the first in every way, except that the second robot helps the first and has been passed different arguments than the first.

In a recursive function, the second robot *may call a third*; and the third may call a fourth, and so on. Each of these is a different entity; but *all are clones*. The last robot *should also know when to stop*.

#+BEGIN_EXAMPLE
     (defun name-of-recursive-function (argument-list)
       "documentation..."
       (if do-again-test
         body...
         (name-of-recursive-function
              next-step-expression)))
#+END_EXAMPLE

** Regexp Search
Two functions ~forward-sentence~ and ~forward-paragraph~ are examples of using *regex* patterns. Check out these two articles online Regexp Search and Regular Expressions.

*** ~sentence-end~
Clearly, a sentence may be ended by a period, a question mark, or an exclamation mark. Indeed, in English, only clauses that end with one of those three characters should be considered the end of a sentence. This means that the pattern should include the character set: ~[.?!]~

Typically, the way you would indicate the end of a sentence is by a double space after a period, question or exclamation mark. But sometimes, it may also be the end of a line or a tab. So we'll teach regex to search for these three patterns.
#+BEGIN_EXAMPLE
     \\($\\| \\|  \\)
            ^   ^^
           TAB  SPC
#+END_EXAMPLE

Here *$* by regex means, the end of a line, the first backslash quotes the following backslash in Emacs; and the second indicates that the following character, the parenthesis or the vertical bar, is special. Also, a sentence may be followed by one or more carriage returns, like this:
#+BEGIN_EXAMPLE
[
]*
#+END_EXAMPLE

The asterisk indicates that the =<RET>= is repeated zero or more times. But a sentence end does not consist only of a period, a question mark or an exclamation mark followed by appropriate space: a closing quotation mark or a closing brace of some kind may precede the space. Indeed more than one such mark or brace may precede the space. These require a expression that looks like this:
#+BEGIN_EXAMPLE
[]\"')}]*
#+END_EXAMPLE

In this expression, the first =]= is the first character in the expression; the second character is ="= which is preceded by a =\= to tell Emacs the ="= is not special. The last three characters are ='=, =)=, and =}=.

All this suggests what the regular expression pattern for matching the end of a sentence should be; and, indeed, if we evaluate sentence-end we find that it returns the following value:
#+BEGIN_EXAMPLE
     sentence-end
          "[.?!][]\"')}]*\\($\\|     \\|  \\)[
     ]*"
#+END_EXAMPLE

*** ~forward-sentence~
Here is the code for ~forward-sentence~:
#+BEGIN_EXAMPLE
     (defun forward-sentence (&optional arg)
       "Move forward to next end of sentence.  With argument, repeat.
     With negative argument, move backward repeatedly to start of sentence.

     The variable `sentence-end' is a regular expression that matches ends of
     sentences.  Also, every paragraph boundary terminates sentences as well."
       (interactive "p")
       (or arg (setq arg 1))
       (let ((opoint (point))
             (sentence-end (sentence-end)))
         (while (< arg 0)
           (let ((pos (point))
                 (par-beg (save-excursion (start-of-paragraph-text) (point))))
            (if (and (re-search-backward sentence-end par-beg t)
                     (or (< (match-end 0) pos)
                         (re-search-backward sentence-end par-beg t)))
                (goto-char (match-end 0))
              (goto-char par-beg)))
           (setq arg (1+ arg)))
         (while (> arg 0)
           (let ((par-end (save-excursion (end-of-paragraph-text) (point))))
            (if (re-search-forward sentence-end par-end t)
                (skip-chars-backward " \t\n")
              (goto-char par-end)))
           (setq arg (1- arg)))
         (constrain-to-field nil opoint t)))
#+END_EXAMPLE

** Counting Words
Repetition and regular expression searches are powerful tools that you often use when you write code in Emacs Lisp. This chapter illustrates the use of regular expression searches through the construction of word count commands using while loops and recursion.

*** Why count words
Certain types of writing ask you to count words. Thus, if you write an essay, you may be limited to 800 words; if you write a novel, you may discipline yourself to write 1000 words a day. It seems odd, but for a long time, Emacs lacked a word count command. Perhaps people used Emacs mostly for code or types of documentation that did not require word counts; or perhaps they restricted themselves to the operating system word count command, wc. Alternatively, people may have followed the publishers' convention and computed a word count by dividing the number of characters in a document by five.

*** The ~count-words-example~ Function
Clearly, counting words is a repetitive act: starting from the beginning of the region, you count the first word, then the second word, then the third word, and so on, until you reach the end of the region. This means that word counting is ideally suited to *recursion* or to a *while* loop.

**** Designing ~count-words-example~
We'll want to pass 2 arguments that specify our *start* and *end* points in the marked region.

#+BEGIN_EXAMPLE
     ;;; First version; has bugs!
     (defun count-words-example (beginning end)
       "Print number of words in the region.
     Words are defined as at least one word-constituent
     character followed by at least one character that
     is not a word-constituent.  The buffer's syntax
     table determines which characters these are."
       (interactive "r")
       (message "Counting words in region ... ")

     ;;; 1. Set up appropriate conditions.
       (save-excursion
         (goto-char beginning)
         (let ((count 0))

     ;;; 2. Run the while loop.
           (while (< (point) end)
             (re-search-forward "\\w+\\W*")
             (setq count (1+ count)))

     ;;; 3. Send a message to the user.
           (cond ((zerop count)
                  (message
                   "The region does NOT have any words."))
                 ((= 1 count)
                  (message
                   "The region has 1 word."))
                 (t
                  (message
                   "The region has %d words." count))))))
#+END_EXAMPLE

**** The whitespace bug in ~count-words-example~
The count-words-example command described in the preceding section has two bugs, or rather, one bug with two manifestations. First, if you mark a region containing only whitespace in the middle of some text, the count-words-example command tells you that the region contains one word! Second, if you mark a region containing only whitespace at the end of the buffer or the accessible portion of a narrowed buffer, the command displays an error message that looks like this: ~Search failed: "\\w+\\W*"~

The new updated function would look like this:
#+BEGIN_EXAMPLE
     ;;; Final version: while
     (defun count-words-example (beginning end)
       "Print number of words in the region."
       (interactive "r")
       (message "Counting words in region ... ")

     ;;; 1. Set up appropriate conditions.
       (save-excursion
         (let ((count 0))
           (goto-char beginning)

     ;;; 2. Run the while loop.
           (while (and (< (point) end)
                       (re-search-forward "\\w+\\W*" end t))
             (setq count (1+ count)))

     ;;; 3. Send a message to the user.
           (cond ((zerop count)
                  (message
                   "The region does NOT have any words."))
                 ((= 1 count)
                  (message
                   "The region has 1 word."))
                 (t
                  (message
                   "The region has %d words." count))))))
#+END_EXAMPLE

** TODO Words in a ~defun~
** TODO Readying a Graph
** TODO Emacs Initialization
*** ~defcustom~
Allows you to specify a variable that's customizable by users. Here is an example ~defcustom~ macro:
#+BEGIN_EXAMPLE
     (defcustom text-mode-hook nil
       "Normal hook run when entering Text mode and many related modes."
       :type 'hook
       :options '(turn-on-auto-fill flyspell-mode)
       :group 'wp)
#+END_EXAMPLE

** TODO Debugging
** TODO Conclusion
** TODO ~the-the~
** TODO Kill Ring
** TODO Full Graph
#+BEGIN_SRC emacs-lisp
(after! org
  (set-company-backend! 'org-mode 'company-capf '(company-dabbref :with company-yasnippet)))


#+END_SRC
* EXAMPLES
** Looping Through Lists
Here is an example Function using ~progn~ with a loop condition to parse a list.
#+BEGIN_SRC emacs-lisp
(setq org-gtd-task-files '("next.org" "coding.org"))
(prog1 (car org-gtd-task-files) (setq org-gtd-task-files (cdr org-gtd-task-files)))
(setq org-agenda-files (list (prog1 (concat org-gtd-folder (car org-gtd-task-files))))
#+END_SRC
* REFERENCE MANUAL
** Nonlocal Exits
A nonlocal exit is a transfer of control from one point in a program to another remote point. Nonlocal exits can occur in Emacs Lisp as a result of errors; you can also use them under explicit control. Nonlocal exits unbind all variable bindings made by the constructs being exited.
** Lists
*** Association Lists
#+BEGIN_SRC emacs-lisp
(setq org-next-task-files '("next.org" "coding.org"))
(list org-next-task-files)
(defun print-elements-of-list (list)
  "Print each element of LIST on a line of its own."
  (let ((files (list list)))
  (while files
    (setq org-gtd-task-files (append (pop list))))))
(print-elements-of-list org-next-task-files)
(ivy-completing-read "Select: " (list org-next-tasks-files))
(find-file "Select file: " (concat org-next-task-files))
#+END_SRC
** Buffers
:PROPERTIES:
:ID:       9762e42f-3606-4e44-b10c-d5100c9c5018
:END:
*** Overview
Buffer is essentially a Lisp Object, which can hold text and sometimes, but not always, be manipulated (See Read Only Buffers and Indirect Buffers). Buffers that are visiting files will contain the contents of those files, also referenced as Text. Some buffers may be read-only and only provide informational data... There is always a current-buffer...

Buffers can include a range of information that's provided by Variables, or in some other cases by primitive functions.

Buffers also use buffer-local Variables, which essentially allow the buffers to change variables that are directly accessible by the buffer. For more details check out the Buffer Local Variables.

When an editing command returns to the editor command loop, Emacs automatically calls set-buffer on the buffer shown in the selected window. This is to prevent confusion: it ensures that the buffer that the cursor is in, when Emacs reads a command, is the buffer to which that command applies (see Command Loop). Thus, you should not use set-buffer to switch visibly to a different buffer; for that, use the functions described in Switching Buffers.
*** Buffer File Names :buffer:
The buffer file name is the name of the file that is visited in that Buffer. When a buffer is not visiting a file, its buffer file name is ~nil~. Most of the time, the buffer name is the same as the nondirectory part of the buffer file name, but the ~buffer file name~ and ~buffer name~ are distinct and can be set independently. See Visiting Files.
#+RESULTS:
: /home/nick/.org/notes/programming/elisp.org

**** ~buffer-file-name~ :function:
This Function returns the absolute file name of the file that buffer is visiting. If buffer is not visiting any file, buffer-file-name returns nil. If buffer is not supplied, it defaults to the current buffer. (see Elisp Function References)
: (buffer-file-name (other-buffer))
**** buffer-file-name :variable:
This Buffer Local Variable, Variable contains the name of the file being visited in the current Buffer, or nil if it is not visiting a file. It is a permanent local variable, unaffected by kill-all-local-variables.

It is risky to change this variable's value without doing various other things. Normally it is better to use =set-visited-file-name= (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.
**** buffer-file-truename :variable:
This Buffer Local Variable holds the abbreviated truename of the file visited in the current buffer, or nil if no file is visited. It is a permanent local, unaffected by kill-all-local-variables. See Truenames and Directory Names.
**** buffer-file-number :variable:
This Buffer Local Variable holds the file number and directory device number of the file visited in the current buffer, or nil if no file or a nonexistent file is visited. It is a permanent local, unaffected by kill-all-local-variables.

The value is normally a list of the form (filenum devnum). This pair of numbers uniquely identifies the file among all files accessible on the system. See the function =file-attributes=, in File Attributes, for more information about them.

If =buffer-file-name= is the name of a symbolic link, then both numbers refer to the recursive target.
**** get-file-buffer :function:
This Function returns the buffer visiting file filename. If there is no such buffer, it returns nil. The argument filename, which must be a String, is expanded (see File Name Expansion), then compared against the visited file names of all live buffers. Note that the buffer's buffer-file-name must match the expansion of filename exactly. This function will not recognize other names for the same file. (See Elisp Function References)

#+BEGIN_EXAMPLE
(get-file-buffer "buffers.texi")
⇒ #<buffer buffers.texi>
#+END_EXAMPLE

In unusual circumstances, there can be more than one buffer visiting the same file name. In such cases, this function returns the first such buffer in the buffer list.
**** find-buffer-visiting :function:
This Function is like =get-file-buffer=, except that it can return any buffer visiting the file possibly under a different name. That is, the buffer's =buffer-file-name= does not need to match the expansion of filename exactly, it only needs to refer to the same file. If predicate is non-nil, it should be a function of one argument, a buffer visiting filename. The buffer is only considered a suitable return value if predicate returns non-nil. If it can not find a suitable buffer to return, =find-buffer-visiting= returns nil. (See Elisp Function References)
**** set-visited-file-name :function:
If =filename= is a non-empty String, this Function changes the name of the file visited in the current buffer to filename. (If the buffer had no visited file, this gives it one.) The next time the buffer is saved it will go in the newly-specified file. (See Elisp Function References)

This command marks the buffer as modified, since it does not (as far as Emacs knows) match the contents of filename, even if it matched the former visited file. It also renames the buffer to correspond to the new file name, unless the new name is already in use.

If filename is nil or the empty string, that stands for “no visited file”. In this case, set-visited-file-name marks the buffer as having no visited file, without changing the buffer's modified flag.

Normally, this function asks the user for confirmation if there already is a buffer visiting filename. If no-query is non-nil, that prevents asking this question. If there already is a buffer visiting filename, and the user confirms or no-query is non-nil, this function makes the new buffer name unique by appending a number inside of ‘<...>’ to filename.

If along-with-file is non-nil, that means to assume that the former visited file has been renamed to filename. In this case, the command does not change the buffer's modified flag, nor the buffer's recorded last file modification time as reported by visited-file-modtime (see Modification Time). If along-with-file is nil, this function clears the recorded last file modification time, after which visited-file-modtime returns zero.

When the function set-visited-file-name is called interactively, it prompts for filename in the minibuffer.
**** list-buffers-directory :variable:
This Buffer Local Variable specifies a string to display in a buffer listing where the visited file name would go, for buffers that don't have a visited file name. Dired buffers use this variable.
*** Buffer Gap
Essentialy, Emacs uses a "gap" on Buffers to make insertion and deletion faster. Insertion works by filling in part of hte gap, and deletion adds to it. This is why your first edit, particularly in a large buffer, after just editing in another far-away part, sometimes has a noticeable delay.

This function works invisibly, and should not be seen by Functions.

**** gap-position :function:
This Function returns the current gap position in the current buffer. (See Elisp Function References)
**** gap-size
This Functions returns the current gap size of the current buffer. (See Elisp Function References)
*** Buffer List
The Buffer list is a list of active buffers, ordered by how recently the buffer was used. Creating a new buffer will put it at the end of this list, or killing a buffer will remove it. The buffer will be placed to the top of the list if it's displayed or made active. See Switching Buffers or Selecting Windows.

It's also possible to move a buffer to the end of the list with =bury-buffer=. There are no Functions available that will modify this buffer list.

In addition to this, Emacs also keeps a local buffer list for Frames, in which buffers that had been displayed or had their window displayed in that Frame come first. This order is recorded in the frames =buffer-list= frame parameter; see Buffer Parameters.

**** buffer-list &optional frame :function:
This Function returns the buffer list, including those that begin with a space (_Messages). (See Elisp Function References)

If the optional /frame/ argument is specified, it'll return that frames local =buffer-list=, otherwise the fundamental buffer list is used. The buffers appear in most recently active or displayed, regardless of what frames they were displayed in.

#+caption: example buffer-list function
#+BEGIN_EXAMPLE
          (buffer-list)
               ⇒ (#<buffer buffers.texi>
                   #<buffer  *Minibuf-1*> #<buffer buffer.c>
                   #<buffer *Help*> #<buffer TAGS>)

          ;; Note that the name of the minibuffer
          ;;   begins with a space!
          (mapcar (function buffer-name) (buffer-list))
              ⇒ ("buffers.texi" " *Minibuf-1*"
                  "buffer.c" "*Help*" "TAGS")
#+END_EXAMPLE

The list returned by buffer-list is controlled specifically by the function, here's an example of how you could change the way it's ordered though:

#+caption: buffer-list alternative sorting
#+BEGIN_EXAMPLE
     (defun reorder-buffer-list (new-list)
       (while new-list
         (bury-buffer (car new-list))
         (setq new-list (cdr new-list))))
#+END_EXAMPLE

To change the order of a specific frame's buffer-list, set that frame's buffer-list parameter with =modify-frame-parameters=. See Parameter Access.
**** other-buffer &optional buffer visibile-ok frame :function:
This Function displays the next buffer in the buffer-list other than what's currently active. The currently active buffer, will then get assigned to the buffer-list. (in frame =frame=, or else the selected frame, see Input Focus). Buffers whose names start with a space are not considered. (See [[file:../programming/elisp-functions-reference.org][Elisp Function References]])... If buffer is not provided, then the first buffer in the buffer-list is provided.

If frame is non ~nil~, then the buffer-list will contain candidates from the specified Frame. See Buffer Parameters.

If =visible-ok= is ~nil~, =other-buffer= avoids returning a buffer visible in any window, in any visible frame, except as a last resort.

If no suitable buffer exists, then ~*scratch*~ buffer is called.
**** last-buffer &optional buffer visible-ok frame :function:
Returns the last buffer in the frame's buffer-list, other than =buffer=. Unless frame is ~nil~, then it will pull from the active frame. (See Elisp Function References)

The argument =visible-ok= is handled as with =other-buffer= listed above.
**** bury-buffer &optional buffer-or-name :function:
This Function command puts =buffer-or-name= at the end of the list, without changing the order of the buffer-list. This function operates on each frame's buffer-list, in addition, to the active window as well. Check out Window History. (See Elisp Function References)

If the Argument =buffer-or-name= is ~nil~, this means to act on the current buffer. If this buffer is currently displayed in the active Window, that active window is deleted or another buffer is set to the =current-buffer=. More precisely, if the selected window is dedicated (See Dedicated Windows) and there are other windows on its frame, the window is deleted. If it is the only window on its frame and that frame is not the only frame on its terminal, the frame is dismissed by calling the function specified by =frame-auto-hide-function= (See Quitting Windows). Otherwise, it calls =switch-to-prev-buffer= (See Window History) to show another buffer in that window.  If =buffer-or-name= is displayed in some other window, it remains displayed there.

To replace a buffer in all the windows that display it, use =replace-buffer-in-windows=, see Buffers And Windows.
**** unbury-buffer :function:
This Functions command will return the last buffer in teh buffer-list, and make the buffer active in the current buffer by using =switch-to-buffer=. See Switching Buffers. (See Elisp Function References)
**** buffer-list-update-hook :variable:
This is a normal hook run whenever the =buffer-list= changes. Functions running this hook are =get-buffer-create= (See Creating Buffers), =rename-buffer= (See Buffer Names), =kill-buffer= (See Killing Buffers), =bury-buffer= (see above) and finally =select-window= (see Selecting Windows).
*** TODO Buffer Local Variables
*** Buffer Modification
Emacs keeps a flag called the modified flag for each Buffer, to record whether you have changed the Text of the buffer. This flag is set to t whenever you alter the contents of the buffer, and cleared to nil when you save it. Thus, the flag shows whether there are unsaved changes. The flag value is normally shown in the Mode Line (see Mode Line Variables), and controls saving (see Saving Buffers) and auto-saving (see Auto Saving).

Some Lisp programs set the flag explicitly. For example, the function =set-visited-file-name= sets the flag to t, because the text does not match the =newly-visited= file, even if it is unchanged from the file formerly visited.

The functions that modify the contents of buffers are described in Text.

**** buffer-modified-p &optional buffer :function:
This Function returns t if the buffer buffer has been modified since it was last read in from a file or saved, or nil otherwise. If buffer is not supplied, the current buffer is tested. (See Elisp Function References)

**** set-buffer-modified-p flag :function:
This Function marks the current buffer as modified if flag is non-nil, or as unmodified if the flag is nil. (See Elisp Function References)

Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer. In fact, the function =force-mode-line-update= works by doing this:

: (set-buffer-modified-p (buffer-modified-p))

**** restore-buffer-modified-p flag :function:
Like set-buffer-modified-p, but does not force redisplay of mode lines. (See Elisp Function References)

**** not-modified &optional arg :command:
This Function command marks the current buffer as unmodified, and not needing to be saved. If arg is non-nil, it marks the buffer as modified, so that it will be saved at the next suitable occasion. Interactively, arg is the prefix argument.

Don't use this function in programs, since it prints a message in the echo area; use =set-buffer-modified-p= (above) instead.

**** buffer-modified-tick &optional buffer :function:
This Function returns buffer's modification-count. This is a counter that increments every time the buffer is modified. If buffer is nil (or omitted), the current buffer is used. The counter can wrap around occasionally. (See Elisp Function References)

**** buffer-chars-modified-tick &optional buffer :function:
This Function returns buffer's character-change modification-count. Changes to text properties leave this counter unchanged; however, each time text is inserted or removed from the buffer, the counter is reset to the value that would be returned by buffer-modified-tick. By comparing the values returned by two buffer-chars-modified-tick calls, you can tell whether a character change occurred in that buffer in between the calls. If buffer is nil (or omitted), the current buffer is used. (See Elisp Function References)

Sometimes there's a need for modifying buffer in a way that doesn't really change its text, like if only its text properties are changed. If your program needs to modify a buffer without triggering any hooks and features that react to buffer modifications, use the with-silent-modifications macro.

**** with-silent-modifications body :macro:
Execute body pretending it does not modify the buffer. This includes checking whether the buffer's file is locked (see File Locks), running buffer modification hooks (see Change Hooks), etc. Note that if body actually modifies the buffer text, its undo data may become corrupted. Reference Macro.
*** Buffer Names
:PROPERTIES:
:ID:       a00cc170-4cb3-44da-a126-5176442bd1d2
:END:
All Buffers have unique names to identify them, which is a String. Any argumed called =buffer-or-name= (?) is of this sort, and an =error= is signaled if it is neither a string nor a buffer. Any argument called =buffer= must be an actual buffer Lisp Object, not a name. Many Functions will accept a buffer or buffer-name to operate on. (See Elisp Function References)

Buffers that are ephemeral (lasting for a very short time) and generally uninteresting to the user have names starting with a space, so that the =list-buffers= and =buffer-menu= commands don't mention them (but if such a buffer visits a file, it is mentioned). A name starting with space also initially disables recording undo information; see Undo.

**** buffer-name :function:
=buffer-name= Function is used to return the Buffer name as a string, =buffer= defaults to the current buffer. (See Elisp Function References)

If =buffer-name= returns nil, it that buffer has been killed. See Killing Buffers.

#+BEGIN_EXAMPLE
(buffer-name)
⇒ "buffers.texi"

(setq foo (get-buffer "temp"))
⇒ #<buffer temp>

(kill-buffer foo)
⇒ nil

(buffer-name foo)
⇒ nil

foo
⇒ #<killed buffer>
#+END_EXAMPLE
**** rename-buffer :function:
This Function renames the current buffer to /newname/. An error is signaled if /newname/ is not a string. In addition, if /unique/ is set to ~non-nil~ then it modified /newname/ to make a name that is not in use. Interactively, you can make /unique/ ~non-nil~ with a prefix argument. This is how the command =(rename-uniquely)= is implemented. (See Elisp Function References)
**** get-buffer :function:
This Function returns the buffer specified by =buffer-or-name=. If =buffer-or-name= is a string, and there is no buffer with that name, the value is ~nil~. (See Elisp Function References)
#+BEGIN_EXAMPLE
(setq b (get-buffer "lewis"))
⇒ #<buffer lewis>
(get-buffer b)
⇒ #<buffer lewis>
(get-buffer "Frazzle-nots")
⇒ nil
#+END_EXAMPLE

See also the function get-buffer-create in Creating Buffers.
**** generate-new-buffer-name :function:
This Function returns the buffer specified by =buffer-or-name=. If =buffer-or-name= is a string and there is no buffer with that name, the value is nil. If =buffer-or-name= is a buffer, it is returned as given; that is not very useful, so the argument is usually a name. (See Elisp Function References) For example:

#+BEGIN_EXAMPLE
          (setq b (get-buffer "lewis"))
               ⇒ #<buffer lewis>
          (get-buffer b)
               ⇒ #<buffer lewis>
          (get-buffer "Frazzle-nots")
               ⇒ nil
#+END_EXAMPLE
See also the function =get-buffer-create= in Elisp Function References.
*** TODO Buffer Parameters
*** TODO Creating Buffers
*** TODO Current Buffer
*** Indirect Buffers
:PROPERTIES:
:ID:       c613c3e1-c3e7-46a1-9ada-623bfc43aeac
:END:
An _indirect buffer_ shares the text of some other Buffer, which is called the _BASE BUFFER_ of the indirect buffer. In some ways it is the analogue for buffers, of a symbolic link among files. The base buffer itself may not be an indirect buffer. The text of the indirect buffer is always the same as the base buffer, changes made in either one are seen immediately, which includes the Text Properties. In all other aspects, the two are completely seperate from one another.

An indirect buffer _cannot_ visit a file, mean-while a base buffer can and does. Killing Buffers on an indirect buffer does not affect the base buffer, and you will find the base buffer, unless another Functions terminates it, will still exist.

**** make-indierct-buffer base-buffer name &optional clone
This Function will create a new indirect buffer, named =name=, with =base-buffer= pointing back to a buffer. The =clone= option will basically clone all of the base-buffers attribuets, major modes, etc to the indirect buffer. If this is used against another indirect buffer, along with the =clone= flag, it will not clone the indirect buffer you initiated from, but instead clone from the root base buffer. (See Elisp Function References)
**** clone-indirect-buffer newname display-flag &optional
This Function basically creates and returns a new indirect buffer that shares the current buffers base buffer. If =display-flag= is ~non-nil~, then means to display the new buffer by calling =pop-to-buffer=. If =norecord= is ~non-nil~, that means not to put the new buffer to the front of the =buffer-list=. (See Elisp Function References)
**** buffer-base-buffer &optional buffer
This Functions returns the ~base buffer~ of =buffer=, which defaults to the current buffer. If buffer is not indirect buffer, the value returned is ~nil~, otherwise the value returned is the buffer-name of the base buffer. (See Elisp Function References)
*** Killing Buffers
Killing a Buffer rids it from emacs, as well as makes the memory it occupied available for others to use again.

The buffer Lisp Object that's been killed will remain available to buffer's that are using or have reference to it, but the Buffer is specially marked so that you cannot see or access it. If you kill a buffer that's currently active in your window, emacs will automatically switch to a previous buffer.

If you kill a buffer that is the base buffer of one or more indierct buffers (See Fuzzy:../Elisp/Indirect Buffers), the indirect buffers are automatically killed as well.

The =buffer-name= of a Buffer is ~nil~ if, and only if, the buffer is killed. A Buffer that has not been killed is called a ~live~ buffer. To test if a buffer is live or killed, use the Functions =buffer-live-p=.

**** kill-buffer &optional buffer-or-name :function:
This Function kills the buffer =buffer-or-name=, freeing all its memory for other uses or to be returned to the operating system. If =buffer-or-name= is omitted, it kills the =current-buffer=. Side note; this function will not kill the buffer if there's un-saved changes. Instead, it'll first prompt the user if they would like to save changes and then kill the buffer. To skip this, clear the modified flag before calling =kill-buffer=. See Fuzzy:../Elisp/Buffer Modification. This function will return ~t~ if it actually kills the buffer. (See Elisp Function References)

Any processes that have this buffer as the =profess-buffer= are sent the ~SIGHUP~ (hangup) signal, which normally causes them to terminate. See Fuzzy:../Elisp/Signals To Processes.

This buffer then calls =replace-buffer-in-windows= for cleaning up all windows currently displaying the buffer to be killed.

**** kill-buffer-query-functions :variable:
This Functions will basiaclly prompt the user to confirm before killing the buffer. If any of these questions return ~nil~ then the buffer is spared.
**** kill-buffer-hook :variable:
This hook will basically run just before the buffer is killed, after the user has answered all the prompts. See Hooks.
**** buffer-offer-save :variable:
This Variable basically offers the function =save-buffers-kill-emacs= to save that buffer, just as it offers to save file-visiting buffers.
**** buffer-save-without-query :variable:
This Variable basically tells the Functions =save-buffer-kill-emacs= and =save-some-buffers= to save the buffer with-out prompting the user.
**** buffer-live-p object :function:
This Functions returns ~t~ if the Lisp Object is a live Buffer, ~nil~ otherwise. (See Elisp Function References)
*** Modification Time
Emacs essentially makes note of when a file is modified, both at local disk level and by a Buffer. This comes in handy whenver you make a change to the buffer, but prior to your changes, the system or external application made a modification at the file-system level. If you were to save the buffer without this feature, Emacs would simplhy over-write the changes made at the file-system level. Check out File Attributes for more information on how to access this information.

Some example functions below can help Emacs and the user determine modification times.

**** verify-file-visited-modtime & optional buffer :function:
This Function esentially compares what (usually your =current-buffer=) the buffer's visiting file has marked for modification time, vs what the operating system shows. The two should be the same prior to Emacs saving changes back to the file-system. The value of this function will return ~t~ if both systems match, otherwise it will return ~nil~, or lastly if the visited file has no last modified time. (See Elisp Function References)

In other circumstances, this function will return ~t~ if the visited file does not exist yet, or for a dired buffer. Lastly, it can also return ~nil~ if the file visited no longer EXISTS!!
**** clear-visited-file-modtime :function:
This Function essentially clears the modified time on the visited file currently in the Buffer. As a result, the next attempt to save the file will not complain about any modified time discrepancy's. (See Elisp Function References)
**** visited-file-modtime :function:
This Function returns the current buffer's, last file, modification time, as a list of the form (high low microsec picosec). This is the same format that =file-attributes= uses to return file modification values. See Fuzzy:../Elisp/File Attributes. (Reference Elisp Function References)
**** set-visited-file-modtime :function:
This Function essentially takes a buffer's visited file, and writes to the modification time of the file set by =time=, unless =time= is ~nil~, and otherwise set to the last modification of the visited file. (See Elisp Function References)
**** ask-user-about-supression-thread filename :function:
This Function essentially will ask a user how to proceed if the modification time of the visited file is newer, than the buffer's modification time. Emacs detects this because the modification time is newer on disk, then what Emacs has last recorded.

Depending on the users response, the function will either save the buffer text to the visited file and update the modification time, otherwise it may throw a =file-supression= error with data (filename), in which case the buffer's changes are not saved. See also Fuzzy:../Elisp/File Locks. (Referenec Elisp Function References)
*** Operate temporarily on another buffer
To operate temporarily on another buffer, put the set-buffer within a =save-current-buffer= form. Here, as an example, is a simplified version of the command =append-to-buffer=:

#+BEGIN_EXAMPLE
     (defun append-to-buffer (buffer start end)
       "Append the text of the region to BUFFER."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (save-current-buffer
           (set-buffer (get-buffer-create buffer))
           (insert-buffer-substring oldbuf start end))))
#+END_EXAMPLE

Here, we bind a local variable to record the current buffer, and then save-current-buffer arranges to make it current again later. Next, =set-buffer= makes the specified buffer current, and =insert-buffer-substring= copies the string from the original buffer to the specified (and now current) buffer.

Alternatively, we can use the with-current-buffer macro:

#+BEGIN_EXAMPLE
     (defun append-to-buffer (buffer start end)
       "Append the text of the region to BUFFER."
       (interactive "BAppend to buffer: \nr")
       (let ((oldbuf (current-buffer)))
         (with-current-buffer (get-buffer-create buffer)
           (insert-buffer-substring oldbuf start end))))
#+END_EXAMPLE

In either case, if the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed. If it is not displayed in any window, you will not see the change immediately on the screen. The command causes the buffer to become current temporarily, but does not cause it to be displayed.

If you make local bindings (with let or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding's scope. Otherwise you might bind it in one buffer and unbind it in another!

Do not rely on using =set-buffer= to change the current buffer back, because that won't do the job if a quit happens while the wrong buffer is current. For instance, in the previous example, it would have been wrong to do this:

#+BEGIN_EXAMPLE
       (let ((oldbuf (current-buffer)))
         (set-buffer (get-buffer-create buffer))
         (insert-buffer-substring oldbuf start end)
         (set-buffer oldbuf))
#+END_EXAMPLE

Using =save-current-buffer= or =with-current-buffer=, as we did, correctly handles quitting, errors, and throw, as well as ordinary evaluation.
*** Read Only Buffers
If a Buffer is read-only, then obviously you cannot make any changes to it. You can only use it in two ways, depending on the goal of what you're trying to achieve.
- Buffer's visiting file is read-only and locked by the file-system, or due to permissions.
- Modes such as Dired and Rmail make buffers read-only.

**** buffer-read-only :variable:
This Buffer Local Variable specifies if the buffer is read-only, which if it's read-only the value returned is ~non-nil~. However, characters that have the =inhibit-read-only= text property can still be modified. Check out Special Properties.
**** inhibit-read-only :variable:
If this Variable is ~non-nil~ then read-only buffers, and depending on the actual value, some or all read-only characters may be modified. read-only text are those that have ~non-nil~ =read-only= Text Properties. See Special Properties.

If =inhibit-read-only= is ~t~ then all =read-only= character properties have no affect. If =inhibit-read-only= is a List, then =read-only= character properties have no affect if they are members of the list. (comparison is done with eq)
**** read-only-mode &optional ARG :function:
This Function is the command for setting a Buffer to read-only mode, a Buffer local minor mode. See Fuzzy:../Elisp/Minor Mode Conventions. (Reference Elisp Function References)

This minor mode servers mostly as a wrapper for =buffer-read-only=; unlike most others, there is no seperate =read-only-mode= variable. Even when =read-only-mode= is disabled, characters with non ~nil~ =read-only= Fuzzy:../Elisp/Text Properties remain read-only.

When enabling =read-only-mode=, this also enables =view-mode= if the option =view-read-only= is non ~nil~. See Fuzzy:../Elisp/Miscellaneous Buffer Operations. When disabling =read-only-mode=, it also disables =view-mode= if it was enabled.
**** barf-if-buffer-read-only &optional position :function:
This Function signals a =buffer-read-only= error if the current buffer is =read-only=. If the Text at /position/ (which defaults to =point=) has the =inhibit-read-only= Fuzzy:../Elisp/Text Properties set, the error will not be raised. (See Elisp Function References)

Check out Fuzzy:../Elisp/Using Interactive, for another way to signal an error if the current buffer is =read-only=.
*** Swapping Text
Basically, allow the user to access several different types of text in the Buffer. This could be implemented with multiple buffers, or with narrowing. (See Fuzzy:../Elisp/Narrowing)

Another method to quickly swap text between two Buffers is by using the Function =buffer-swap-text=. This function does not move any text, it only changes the internal Data Structure of the buffer Lisp Object to point to a different chunk of text.

**** buffer-swap-text buffer
This Function will swap all of the Buffers text between the targeted and referenced buffers, unless one of the two is an indirect buffer (see Indirect Buffers) or is a base buffer of an indirect buffer. (In other words, an indirect buffer is "live" and using the base buffer). All of the buffer properties are also swapped in this process. the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the =enable-multibyte-characters= flag (see Text Representation), etc. (Reference Elisp Function References)
** Byte Compilation
** Control Structures
A list program is essentially a list of functions that are executed, but what controls that order of execution? Well, that is what the control struture. Control structures are special forms that control *when*, *whether*, or *how many* times to execute.
*** Sequencing
**** ~progn~
The simplest of ways to control the sequencing of execution, is through ~progn~. This special form evaluates all of the forms, in textual order, returning the result of the final form. Alternatively, you can also use ~prog1~ or ~prog2~. (See Elisp Function References)

#+BEGIN_SRC emacs-lisp
(progn (print "The first form")
       (print "The second form")
       (print "The third form"))
#+END_SRC
*** Conditionals
Elisp has 5 major conditional forms: *if*, *which*, *when* and *unless*. Check out Fuzzy:../Elisp/Pattern-Matching Conditional.
**** ~if~ /condition then-form else-forms/
If will choose between ~then-form~ and ~else-form~ depending on if it's condition returns ~t~ or ~nil~. (See Elisp Function References)
**** ~when~ /condition then-form/
This is a variant of the ~if~ form, because there is no ~else-form~. The body is only executed when the condition is ~t~ or *true*. (See Elisp Function References)
**** ~unless~ /condition forms/
This is a variant of ~if~ in that there is no ~then-form~, essentially meaning if the condition returns *false* or ~nil~, then body is executed. (See Elisp Function References)
**** ~cond~ /clause/
~cond~ chooses among an arbitrary number of alternatives. Each clause in the cond must be a *list*. The car of this list is the *condition*; the remaining elements, if any, the body-forms. (See Elisp Function References) Thus, a clause looks like this: ~(condition body-forms...)~. ~cond~ tries the clauses in textual order, by evaluating the condition of each clause. If the value of condition is *non-nil*, the clause succeeds; then cond evaluates its body-forms, and returns the value of the last of body-forms. Any remaining clauses are ignored. If the value of condition is *nil*, the clause fails, so the cond moves on to the following clause, trying its condition.

The following expression will return *default*, because the first clause is looking for =a= to equal =foo=, otherwise return =default=.
#+BEGIN_SRC emacs-lisp
(setq a 5)
(cond ((eq a 'hack) 'foo)
      (t "default"))
#+END_SRC
*** Combining Conditions
There are three constructs that combine the results to return ~t~ or *true* before evaluating the body, they are...
**** ~not~ /condition/
This function tests for the falsehood of condition. It returns t if condition is nil, and nil otherwise. The function not is identical to null, and we recommend using the name null if you are testing for an empty list. (See Elisp Function References)
**** ~and~ /condition/
Tests rather all the conditions are *true* before evaluating the body. It works by evaluating each of the conditions, one-by-one in the order they are entered. (See Elisp Function References)
**** ~or~ condition
This will test and perform the body so long as one of the experssions returns *true* or ~t~. (See Elisp Function References)
*** TODO Pattern-Matching Conditional
Aside from the four basic conditional forms, Emacs Lisp also has a pattern-matching conditional form, the ~pcase~ macro, a hybrid of ~cond~ and ~cl-case~ (see Fuzzy:../Elisp/Conditionals) that overcomes their limitations and introduces the pattern matching programming style. The limitations that pcase overcomes are:

1. The ~cond~ form chooses among alternatives by evaluating the predicate condition of each of its clauses (see Conditionals). The primary limitation is that variables let-bound in condition are not available to the clause's body-forms.
   - Another annoyance (more an inconvenience than a limitation) is that when a series of condition predicates implement equality tests, there is a lot of repeated code. (cl-case solves this inconvenience.)
2. The ~cl-case~ macro chooses among alternatives by evaluating the equality of its first argument against a set of specific values.
   - Its limitations are two-fold:
   - The equality tests use eql.
   - The values must be known and written in advance.
   - These render cl-case unsuitable for strings or compound data structures (e.g., lists or vectors). (cond doesn't have these limitations, but it has others, see above.)
**** ~pcase~ /EXP &rest CASES/
Each clause in clauses has the form: ~(pattern body-forms...)~. Evaluate expression to determine its value, =expval=. Find the first clause in clauses whose pattern matches =expval= and pass control to that clause's body-forms. If there is a match, the value of pcase is the value of the last of body-forms in the successful clause. Otherwise, pcase evaluates to =nil=. (See Elisp Function References) source -> pcase-macro

So Basically, ~pcase~ will run the initial *expression* and then each clause in the forms, whichever one matches the expression, will evaluate it's body forms. (See Elisp Function References)
**** ~pcase-defmacro~ /name args [doc] &rest body/
Define a new kind of pattern for ~pcase~, to be invoked as (name ~actual-args~). The ~pcase~ macro expands this into a function call that *evaluates* body, whose job it is to rewrite the invoked pattern into some other pattern, in an environment where args are bound to actual-args. (See Elisp Function References)

Additionally, arrange to display doc along with the docstring of pcase. By convention, doc should use ~EXPVAL~ to stand for the result of evaluating expression (first arg to pcase).

#+BEGIN_EXAMPLE
     (pcase-defmacro less-than (n)
       "Matches if EXPVAL is a number less than N."
       `(pred (> ,n)))

     (pcase-defmacro integer-less-than (n)
       "Matches if EXPVAL is an integer less than N."
       `(and (pred integerp)
             (less-than ,n)))
#+END_EXAMPLE
*** Iteration
Iteration means executing a program *repeatedly*.
**** ~while~ /condition forms/
If the condition is *true* or ~t~, the forms are evaluated in order, and then it'll re-evaludate the *condition* and repeat this cycle so long as the condition is always *true*. In this instance, you have to be careful to make sure you do not create an endless loop. (See Elisp Function References)
**** ~dolist~ /(var list [result] body)/
This macro will evaluate each element of the list, and return the results of that list. (See Elisp Function References)
**** ~dotimes~ /(var count [result] body)/
This construct executes body once for each integer from 0 (inclusive) to count (exclusive), binding the variable var to the integer for the current iteration. Then it returns the value of evaluating result, or nil if result is omitted. Here is an example of using dotimes to do something 100 times. (See Elisp Function References)
*** Generators
A generator is a function that produces a *potentially-infinite* stream of values. Each time the function produces a value, it suspends itself and waits for a caller to request the next value.
**** ~iter-defun~ /name args [doc] [declare] [interactive] body/
iter-defun defines a generator function. A generator function has the same signature as a normal function, but works differently. Instead of executing body when called, a generator function returns an iterator object. That iterator runs body to generate values, emitting a value and pausing where iter-yield or iter-yield-from appears. When body returns normally, iter-next signals iter-end-of-sequence with body's result as its condition data. (See Elisp Function References)
** Forms
*** Special Forms
**** save-current-buffer
The =save-current-buffer= Special Form saves the identity of the current Buffer, evaluates the body forms, and finally restores that buffer as current. The return value is the value of the last form in body. The current buffer is restored even in case of an abnormal exit via throw or error (see Nonlocal Exits).

If the buffer that used to be current has been killed by the time of exit from =save-current-buffer=, then it is not made current again, of course. Instead, whichever buffer was current just before exit remains current.
** Hash Tables
A hash table is a very fast kind of lookup table, somewhat like an alist (see Fuzzy:../Elisp/Association Lists) in that it maps keys to corresponding values. It differs from an alist in these ways:
1. Lookup is very fast in a hash-table, but for smaller tables it may be faster to use an Fuzzy:../Elisp/Association Lists.
2. The data in hash tables are in no particular order.
3. There is no way to share structure between two hash tables.

Hash tables have a special Printed Representation, which consists of =#s= followed by a list specifying the hash tables properties and contents, see Creating Hash. (The initial =#= used in the Printed Representation of objects with no Read represenation, has nothing to do with hash tables.)

Obarrays, are also a kind of hash table, but they are a different type of object and are used only for recording interned Symbols. (See Fuzzy:../Elisp/Creating Symbols)

*** Creating Hash
The main Function for creating hash tables is ~make-hash-table~.

**** make-hash-table /&rest keyword-args/ :function:
This Function creates a new hash table specified by the arguments given. The arguments should consist of alternating keywords and values corresponding them. (See Elisp Function References)

Several keywords make sense in ~make-hash-table~, but the only two that you really need to know about are ~:test~ and ~:weakness~

You can also create a new hash table using the Printed Representation for hash tables. The Lisp reader can read this printed representation, provided each element in the specified hash table has a valid read syntax. For instance, the following specifies a new hash table containing the keys =key1= and =key2= (_both symbols_) associated with =val1= (_a symbol_) and =300= (_a number_) respectively.

#+BEGIN_EXAMPLE
#s(hash-table size 30 data (key1 val1 key2 300))
#+END_EXAMPLE

The Printed Representation for a hash table consists of =#s= followed by a list beginning with =hash-table=. The rest of the list should consist of zero or more property-value pairs specifying the hash table's properties and initial contents. The properties and values are read literally. Valid property names are _size, test, weakness, rehash-size, rehash-threshold, and data_. The data property should be a list of key-value pairs for the initial contents; the other properties have the same meanings as the matching make-hash-table keywords (=:size=, =:test=, etc.), described above.

Note that you cannot specify a hash table whose initial contents include objects that have no _read syntax_, such as _buffers and frames_. Such objects may be added to the hash table after it is created.
***** ~:test~ test
this specifies the method of lookup for this has table, some options available are =eq=, =equal= or =eql=

You can also use ~define-hash-table-test~ (See Defining Hash) to define additional possibilities for test.

****** ~eql~
Keys which are numbers are the same if they are equal, that is, if they are equal in value and either both are integers or both are floating point; otherwise, two distinct objects are never the same.

****** ~eq~
Any two distinct Lisp objects are different as keys.

****** ~equal~
Two Lisp objects are the same, as keys, if they are equal according to equal.

***** ~:weakness~ weak
The _weakness_ of a hash table specifics whether a key or value in the hash table protects it from garbage collection.

The value, /weak/, must be one of =nil=, =key=, =value=, =key-or-value=, =key-and-value=, or =t= which is an Alias for =key-and-value=. If /weak/ is _key_ then the hash table does not prevent its _keys_ from being collected as _garbage_ (if they are not referenced anywhere else); if a particular _key does get collected_, the corresponding association is removed from the hash table.

If /weak/ is =value=, then the hash table _does not prevent values from being collected as garbage_ (if they are not referenced anywhere else); if a particular value _does get collected_, the corresponding association is removed from the hash table.

If /weak/ is =key-and-value= or =t=, _both the key and the value must be live_ in order to preserve the association. Thus, the hash table _does not protect_ either keys or values from garbage collection; if either one is collected as garbage, that removes the association.

If /weak/ is =key-or-value=, either the key or the value _can preserve the association_. Thus, associations _are removed from the hash table_ when both their key and value would be collected as garbage (if not for references from weak hash tables).

The default for /weak/ is =nil=, so that _all keys and values referenced_ in the hash table are preserved from garbage collection.

***** ~size~ /size/
This _specifies a hint_ for _how many associations_ you plan to store in the hash table. If you know the approximate number, you can make things a little more efficient by specifying it this way. If you specify too small a size, the hash table will grow automatically when necessary, but doing that takes some extra time.

The default size is =65=

***** ~rehash-size~ /rehash-size/
When you add an association to a hash table and the table is full, _it grows automatically_. This value specifies how to make the hash table larger, at that time. _If rehash-size is an integer_, it should be positive, and the hash table grows by adding approximately that much to the nominal size. If _rehash-size is floating point_, it had better be greater than 1, and the hash table grows by multiplying the old size by approximately that number.

The default value is =1.5=

***** ~rehash-threshold~ /threshold/
This specifies the _criterion_ for when the hash table is full (so it should be made larger). The value, =threshold=, should be a _positive floating-point number_, no greater than 1. The hash table is full whenever the actual number of entries exceeds the nominal size multiplied by an approximation to this value. The default for threshold is =0.8125=.
*** Hash Access
Described the Functions for accessing and storing Associations in a hash table.

**** get-hash /key table &optional default/ :function:
This Functions looks up key in table, and returns its associated value - or /default/, if key has no association in table. (See Elisp Function References)

**** put-hash /key value table/ :function:
This Function enters an association for key in table, with value =value=. If key _already has an association in table_, value replaces the old associated value. (See Elisp Function References)

**** remhash /key table/ :function:
This Function removes the association for key from table, if there is one. If key has no association, remhash does nothing. (See Elisp Function References)

*Common Lisp note:* In Common Lisp, ~remhash~ returns non-nil if it actually removed an association and nil otherwise. In Emacs Lisp, remhash always returns nil.

**** clrhash /table/ :function:
This Function removes all the associations from hash table table, so that it becomes empty. This is also called clearing the hash table. (See Elisp Function References)

*Common Lisp note:* In Common Lisp, clrhash returns the empty table. In Emacs Lisp, it returns nil.

**** maphash /function table/ :function:
This Function calls =function= once for each of the associations in table. The function =function= should accept two arguments -- key listed in table, and its associated value. ~maphash~ returns nil. (See Elisp Function References)
*** Defining Hash
You can define new methods of key lookup by means of ~define-hash-table-test~. In order to use this feature, you need to understand how hash tables work, and what a hash code means.

You can think of a hash table conceptually as a _large array of many slots_, each capable of holding one association. To look up a key, ~gethash~ first computes an integer, _the hash code_, from the key. It reduces this integer modulo the length of the array, to produce an index in the array. Then it looks in that slot, and if necessary in other nearby slots, to see if it has found the key being sought.

Therefore, to define a new method of key lookup, you need to specify two Functions to a) compute the hash code from a key and b) compare the two keys directly.

**** define-hash-table-test /name test-fn hash-fn/ :function:
This function defins a new hash table test, named =name= (See Elisp Function References)
** Lisp Data Types
A Lisp Object is a piece of data used and manipulated by Lisp programs. For our purposes, a type or data type is a set of possible ojects. Every object belongs to at-least one type. Objects of the same type have similar structures, and can be used in the same contexts. Types can overlap, and a Lisp Object can contain multiple types.

A few fundamental object types are built into emacs. These, from which all other types are constructed, are called Primitive types.
- integer
- float
- cons
- symbol
- string
- vector
- hash-table
- subr
- byte-code function
- record
- buffer

Lisp is unlike many other languages in that its objects are self-typing: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.

In most languages, the programmer must declare the data type of each Variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type.

*** Printed Representation
The printed representation of an object is the format of the output generated by the Lisp printer (the function prin1) for that object. Every Data Type has a unique printed representation. The read syntax of an object is the format of the input accepted by the Lisp reader (the function read) for that object. This is not necessarily unique; many kinds of object have more than one syntax.

In most cases, an object's printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in hash notation, which consists of the characters ‘#<’, a descriptive string (typically the type name followed by the name of the object), and a closing ‘>’. For example:

#+BEGIN_EXAMPLE
(current-buffer)
 > #<buffer objects.texi>
#+END_EXAMPLE

Hash notation cannot be read at all, so the Lisp reader signals the error invalid-read-syntax whenever it encounters ‘#<’. In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object's read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.

When you evaluate an expression interactively, the Lisp interpreter first reads the textual representation of it, producing a Lisp object, and then evaluates that object (see Fuzzy:../Elisp/Evaluation). However, evaluation and reading are separate activities. Reading returns the Lisp object represented by the text that is read; the object may or may not be evaluated later. See Fuzzy:../Elisp/Input Functions, for a description of =read=, the basic function for reading objects.
*** Comments
A comment is represented with a =;= before the text.
*** Programmy Types
Types found in all lisp systems
**** Integer Type
The range of values for an integer depends on the machine. The minimum range is =−536,870,912= to =536,870,911= (30 bits; i.e., −2**29 to 2**29 − 1) but many machines provide a wider range. Emacs Lisp arithmetic functions do not check for integer overflow. Thus (1+ 536870911) is −536,870,912 if Emacs integers are 30 bits.

As a special exception, if a number is too large to be read as a integer-type, the Lisp reader reads is as a Floating Point Type.

**** Floating Point Type
Floating-point numbers are the computer equivalent of scientific notation; you can think of a floating-point number as a fraction together with a power of ten. The precise number of significant figures and the range of possible exponents is machine-specific; Emacs uses the C data type double to store the value, and internally this records a power of 2 rather than a power of 10.

The Printed Representation of a floating point, requires a *decimal* point, an exponent or both. Such as =930.0=, =+15e2= or =15.0e+2=.

See Fuzzy:../Elisp/Numbers for more information.
**** Character Type
Characters are nothing more than integers, that Emacs will convert over to a alpha character. These characters are represented by their character codes. For example, the letter =A= character code is =65=.

Characters for the most part are rarely ever used in programs, but it is more common to work with _strings_, which are sequences composed of characters. See Fuzzy:../Elisp/String Type.

Characters in Strings and Characters, along with Buffers are limited to the range of =0 to 4194303-twenty= two bits (see Fuzzy:../Elisp/Character Codes). Codes 0 through 127 are ASCII codes; the rest are Fuzzy:../Elisp/Non-Ascii Characters. Characters that represent keyboard input have a much wider range, to encode modifier keys such as _Control, Shift and Meta_.

There are special functions for producing a human-readable textual description of a character for the sake of messages. See Fuzzy:../Elisp/Describing Characters.

***** Basic Char Syntax
Printed Representation of a character is a decimal number (not sure what they mean by decimal number?). You should _always_ use the special read syntax formats that Emacs Lisp provides for characters. These syntax formats start with a question mark.

The usual read syntax for alphanumeric characters is a =?= question mark followed by the character; thus =?A= for the character =A=, or =?B= for the character =B=, or finally =?a= for the character =a=.

For example: (you can evaluate the below to present your character code)
#+BEGIN_EXAMPLE
?Q > 81
?q > 113
#+END_EXAMPLE

Another thing to note, is that you can also use punctuation, but if the punctuation has a special meaning to Lisp, then you'll need to Escape with =\=.

You can express the characters _control-g, backspace, tab, newline, vertical tab, formfeed, space, return, del and escape_ as =?\a, ?\b, ?\t, ?\n, ?\v, ?\f, ?\s, ?\r, ?\d and ?\e= respectively. (=?\s= followed by a dash has a different meaning-it applies the super modifier to the following character)

These sequences which with with a backslash =\= are also known as Escape sequences, because backslash plays the role of an escape character; this has nothing to do with the character =ESC=.

A backslash is allowed, for a character that's not interpreted by Emacs Lisp reader and treated as a normal character. You should also use a backslash to the previously mentioned ASCII ones, to avoid confusing people reading your code.
***** General Escape Syntax
In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-ASCII text characters.

You can specify characters by their Unicode names, if any. =\N{NAME}= represents the unicode character named _NAME_. Thus, =\N{LATIN SMALL LETTER A WITH GRAVE}= is equivelant to =?à= and notes the Unicode character U+00E0.

You can specify characters by their Unicode values. =?\N{U+X}= repreesnts a character with Unicode code point X, where X is a hexadecimal number.

You can also specify characters by their hexadecimal character codes. A hexadecimal escape sequence consists of a backslash, =x= and the hexadecimal character code. Thus =?\x41= is the character =A=.

You can specify characters by their character code in octal. An octal escape sequence consists of a backslash followed by up to three octal digits; thus, =?\101= for the character =A=.

See also Non-ASCII in Strings.
***** Ctl-Char Syntax
Control characters can also be represented using another method, using a question mark followed by a backslash, caret and the corresponding non-control character, in either upper or lower case. For example, both =?\^I= and =?\^i= are valid read syntax for the character ~C-i~, the character whose value is 9.
***** Meta-Char Syntax
A _meta character_ is a character typed with the <META> modifier key. The integer that represents such a character has the _2**27_ bit set. In a string, the _2*27_ bit attached to an ASCII character indicates a meta character; thus, the meta character that can fit in a string have codes in the range from 128 to 255. See Strings of Events.

The read syntax for meta characters uses =\M-=
***** Other Char Bits
The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters ‘a’ and ‘A’.  But ASCII has no way to represent whether a control character is upper case or lower case.  Emacs uses the 2**25 bit to indicate that the shift key was used in typing a control character.  This distinction is possible only when you use X terminals or other special terminals; ordinary text terminals do not report the distinction.  The Lisp syntax for the shift bit is ‘\S-’; thus, ‘?\C-\S-o’ or ‘?\C-\S-O’ represents the shifted-control-o character.
**** Symbol Type
***** What is a symbol
A Symbol is an object with a name referenced to it. The symbol name serves as the Printed Representation of the symbol. (See Fuzzy:../Elisp/Creating Symbols), no two symbols are the same. A symbol can serve as a variable, a function or to hold a property list. A Symbol whose name starts with a _:_ is called a _Keyword Symbol_. These symbols act automatically as Fuzzy:../Elisp/Constants, and are normally used only by comparing an unknown symbol with a few specific alternatives. See Fuzzy:../Elisp/Constant Variables.

***** Symbol Names
A symbol name can contain any characters, but if the symbol name appears to be a number, you may need to Escape the character so that Elisp reader does not interpret it as the number.
**** Sequence Types
A sequence is a Lisp Object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp, Lists and Arrays. Thus, an object of type list or of type array is also considered a sequence.

Arrays are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, but string elements must be characters, and bool-vector elements must be =t= or =nil=. The characters in a string can have text properties like characters in a buffer (see Fuzzy:../Elisp/Text Properties); vectors and bool-vectors do not support text properties even when their elements happen to be characters. Char-tables are like vectors except that they are indexed by any valid character code.
**** Cons Cell and List Types
A cons cell is an object that consists of two pointers or slots, called the CAR slot and the CDR slot (See CAR CDR & CONS). Each slot can point to or hold to any Lisp Object. We also say that the "the CAR of this cons cell is" whatever object its CAR slot currently points to, and likewise for the CDR.

Lists is a series of cons cells, linked together so that the CDR slot of each cons cell holds either the next cons cell or the empty list. See section Lists, for functions that work on lists. Because most cons cells are used as part of lists, the phrase list structure has come to refer to any structure made out of cons cells.

The names CAR and CDR derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, called the "address" part and the "decrement"; CAR was an instruction to extract the contents of the address part of a register, and CDR an instruction to extract the contents of the decrement. By contrast, "cons cells" are named for the function cons that creates them, which in turn is named for its purpose, the construction of cells. Reference CAR CDR & CONS

Because cons cells are so central to Lisp, we also have a word for "an object which is not a cons cell". These objects are called Atoms.

***** Dotted pair lists
Dotted pair notation is an alternative syntax for cons cells that represents the CAR and CDR explicitly. In this syntax, =(a . b)= stands for a cons cell whose CAR is the object a, and whose CDR is the object b. Dotted pair notation is therefore more general than list syntax. In the dotted pair notation, the list =`(1 2 3)'= is written as =`(1 . (2 . (3 . nil)))'=. For nil-terminated lists, you can use either notation, but list notation is usually clearer and more convenient. When printing a list, the dotted pair notation is only used if the CDR of a cons cell is not a list.

***** Association list type
An association list or a-list is a specially-constructed list whose elements are cons cells. In each element, the CAR is considered a key, and the CDR is considered an associated value. (In some cases, the associated value is stored in the CAR of the CDR.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.

For example for an a-list =(setq alist-of-colors '((rose . red) (lily . white)  (buttercup . yellow)))=, sets the variable =alist-of-colors= to an alist of three elements. In the first element, rose is the key and red is the value.
**** Array Type
An array is made up of an arbituary slots, starting with _0_ and incrementing up. Elisp uses 4 types of Arrays via: Strings and Characters, Vectors, Bool-Vectors, and Char-Tables. The first element has a index of ~0~, the 2nd element has a index of ~1~ and so-on.
**** String Type
A String is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are Constants: evaluation of a string returns the same string.

See section on Strings and Characters.
***** Syntax for Strings
The read syntax for a string is double quote, the string of characters, and a closing double quote: ="string message"=. If your string includes double quotes, then escape them so the Lisp reader does not interpret them as a new string as such ~"\"Some mesage i'm quoting\""~
***** Non-ASCII in Strings
***** Nonprinting Characters
***** Text Props and Strings
**** Vector Type
**** Char-Table Type
**** Bool-Vector Type
**** Hash Table Type
A Hash Table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:
**** Function Type
**** Macro Type
**** Primitive Function Type
**** Byte-Code Function Type
**** Autoload Type
*** TODO Editing Types
*** TODO Circular Objects
*** TODO Type Predicates
*** TODO Equality Predicates
** Modes
*** Mode Line Format
This section describes Variables incorporated by the standard value of Fuzzy:../Elisp/Mode Line Format into the text of the mode line. There is nothing inherently special about these variables; any other variables could have the same effects on the mode line if the value of mode-line-format is changed to use them. However, various parts of Emacs set these variables on the understanding that they will control parts of the mode line; therefore, practically speaking, it is essential for the mode line to use them. Also see Optional Mode Line.

**** mode-line-mule-info :variable:
This variable holds the value of the mode line construct that displays information about the language environment, buffer coding system, and current input method. See Non-Ascii Characters.
**** mode-line-modified :variable:
This variable holds the value of the mode line construct that displays whether the current buffer is modified. Its default value displays ‘**’ if the buffer is modified, ‘--’ if the buffer is not modified, ‘%%’ if the buffer is read only, and ‘%*’ if the buffer is read only and modified.

Changing this variable does not force an update of the mode line.
**** mode-line-frame-identification :variable:
This variable identifies the current Frame. Its default value displays " " if you are using a window system which can show multiple frames, or "-%F " on an ordinary terminal which shows only one frame at a time.
**** mode-line-buffer-identification :variable:
This variable identifies the buffer being displayed in the Window. Its default value displays the buffer name, padded with spaces to at least 12 columns.
**** mode-line-position :variable:
This variable indicates teh position in the Buffer. It's default value displays the buffer percentage and, optionally, the buffer size, the line number and the column number.
**** mode-line-percent-position :user_option:
This option is used in =mode-line-position=. Its value specifies both the buffer percentage to Display (one of nil, "%o", "%p", "%P" or "%q", see %-Constructs) and a width to space-fill or truncate to. You are recommended to set this option with the customize-variable facility.
**** vc-mode :variable:
The variable =vc-mode=, Buffer Local Variable in each buffer, records whether the buffer's visited file is maintained with version control, and, if so, which kind. Its value is a string that appears in the mode line, or nil for no version control.
**** mode-line-modes :variable:
This variable displays the buffer's major and minor Modes. Its default value also displays the recursive editing level, information on the process status, and whether narrowing is in effect.
**** mode-line-remote :variable:
This variable is used to show whether =default-directory= for the current buffer is remote.
**** mode-line-client :variable:
This variable is used to identify emacsclient frames.

The following three variables are used in mode-line-modes:
**** mode-name :variable:
This buffer-local variable holds the “pretty” name of the current buffer's major mode. Each major mode should set this variable so that the mode name will appear in the mode line. The value does not have to be a string, but can use any of the data types valid in a mode-line construct (see Mode Line Data). To compute the string that will identify the mode name in the mode line, use format-mode-line (see Emulating Mode Line).
This Buffer Local Variables holds the “pretty” name of the current buffer's major mode. Each major mode should set this variable so that the mode name will appear in the mode line. The value does not have to be a string, but can use any of the Data Types valid in a mode-line construct (see Mode Line Data). To compute the string that will identify the mode name in the mode line, use format-mode-line (see Emulating Mode Line).
**** mode-line-process :variable:
This Buffer Local Variable contains the mode line information on process status in modes used for communicating with sub-processes. It is displayed immediately following the major mode name, with no intervening space. For example, its value in the *shell* buffer is (":%s"), which allows the shell to display its status along with the major mode as: ‘(Shell:run)’. Normally this variable is nil.
**** mode-line-front-space :variable:
This variable is displayed at the front of the mode line. By default, this construct is displayed right at the beginning of the mode line, except that if there is a memory-full message, it is displayed first.
**** mode-line-end-spaces :variable:
This variable is displayed at the end of the mode line.
**** mode-line-misc-info :variable:
Mode line construct for miscellaneous information. By default, this shows the information specified by =global-mode-string=.
**** minor-mode-alist :variable:
This variable holds an a-list whose elements specify how the mode line should indicate that a minor mode is active. Each element of the =minor-mode-alist= should be a two-element list:

: (minor-mode-variable mode-line-string)

More generally, =mode-line-string= can be any mode line construct. It appears in the mode line when the value of minor-mode-variable is non-nil, and not otherwise. These strings should begin with spaces so that they don't run together. Conventionally, the minor-mode-variable for a specific mode is set to a non-nil value when that minor mode is activated.

minor-mode-alist itself is not buffer-local. Each variable mentioned in the alist should be buffer-local if its minor mode can be enabled separately in each buffer.
**** global-mode-string :variable:
This variable holds a mode line construct that, by default, appears in the mode line just after the which-func-mode minor mode if set, else after mode-line-modes. The command display-time sets global-mode-string to refer to the variable display-time-string, which holds a string containing the time and load information.

The ‘%M’ construct substitutes the value of global-mode-string, but that is obsolete, since the variable is included in the mode line from mode-line-format.

Here is a simplified version of the default value of mode-line-format. The real default value also specifies addition of text properties.

#+BEGIN_EXAMPLE
("-"
mode-line-mule-info
mode-line-modified
mode-line-frame-identification
mode-line-buffer-identification
"   "
mode-line-position
(vc-mode vc-mode)
"   "
mode-line-modes
(which-func-mode ("" which-func-format "--"))
(global-mode-string ("--" global-mode-string))
"-%-")
#+END_EXAMPLE
** Positions
*** Narrowing
Narrowing makes parts of the Buffer invisible to edits, to get around this look at the =what-line= funciton which can see outside of narrowing. Contrary, =count-lines= will narrow a buffer to only what it's interested in.

**** save-restriction :function:
The use of =save-restriction= comes in handy with narrowing, as any code inside of this symbol will return the buffer to its original narrowed state. (See Elisp Function References)

If you use both =save-restriction= and =save-excursion=, restriction should be in the inner-list.
#+BEGIN_SRC emacs-lisp
(save-excursion
  (save-restriction
    body...))
#+END_SRC
**** what-line :function:
This function will print the current line number in the buffer at point. (See Elisp Function References)
#+BEGIN_SRC emacs-lisp
(defun what-line ()
  "Print the current line number (in the buffer) of point."
  (interactive)
  (save-restriction
    (widen)
    (save-excursion
      (beginning-of-line)
      (message "Line %d"
               (1+ (count-lines 1 (point)))))))
(what-line)
#+END_SRC
#+BEGIN_SRC emacs-lisp
(defun show-limitation (&optional arg)
  "Display only the first 60 lines, or otherwise the number passed in as argument."
  (interactive)
  (save-excursion
    (save-restriction
      (widen)
      (buffer-substring (goto-char (point-min)) 60))))
(show-limitation)
(count-lines (goto-char (point-min)) 60)
#+END_SRC
** Strings and Characters
*** Syntax for strings
The read syntax for strings is a double-quote, an arbitrary number of characters, and another double-quote, ="like this"=. To include a double-quote in a string, precede it with a backslash; thus, "\"" is a string containing just a single double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: "this \\ is a single embedded backslash". Reference Evaluation and Lists.

The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an Escape newline--one that is preceded by `\'---does not become part of the string; i.e., the Lisp reader ignores an escaped newline while reading a string. An escaped space `\ ' is likewise ignored.
*** Non-ASCII Characters in Strings
You can include a non ASCII international character in a string Constants by writing it literally. There are two text representations for non-ASCII characters in Emacs strings (and in buffers): unibyte and multibyte.

If the string constant is read from a Multibyte source, such as a multibyte buffer or string, or a file that would be visited as multibyte, then the character is read as a multibyte character, and that makes the string multibyte.

If the string constant is read from a Unibyte source, then the character is read as unibyte and that makes the string unibyte.

You can also represent a Multibyte non-ASCII character with its character code, using a hex escape, =`\xnnnnnnn'=, with as many digits as necessary. (Multibyte non-ASCII character codes are all greater than 256.) Any character which is not a valid hex digit terminates this construct. If the character that would follow is a hex digit, write `\ ' (backslash and space) to terminate the hex escape--for example, `\x8e0\ ' represents one character, `a' with grave accent. `\ ' in a string constant is just like backslash-newline; it does not contribute any character to the string, but it does terminate the preceding hex escape.
*** Nonprinting Characters in Strings
Properly speaking, strings cannot hold Meta Characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of ASCII characters in a string. If you use the =`\M-'= syntax to indicate a meta character in a string constant, this sets the bit of the character in the string. If the string is used in define-key or lookup-key, this numeric code is translated into the equivalent meta character. See section Character Type.

Strings cannot hold characters that have the hyper, super, or alt modifiers.
*** Text Properties in Strings
A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between Strings and Buffers to copy the text's properties with no special effort. See section Text Properties, for an explanation of what text properties mean. Strings with text properties use a special read and print syntax: =#("characters" property-data...)=
** Variables
*** Variable Aliases
*** Colon
Colon is sort of like the single-quote prefix to a symbol, it tells the interpreter that this is a literal symbol, not a variable to be immediately looked-up and substituted with the associated value in the variable table.
* FUNCTION REFERENCES
** DONE Buffers
CLOSED: [2020-11-06 Fri 22:54]
*** get-buffer
Find a named buffer or create one if a buffer of that name does not exist. The get-buffer function returns nil if the named buffer does not exist.
*** mark-whole-buffer
Mark the whole buffer as a region. Normally bound to =C-x h=
*** save-restriction
Basically save whatever narrowing is in use, then perform the actions inside the BODY and return the narrowing to its original state.
*** set-buffer
Switch the attention of Emacs to another buffer, but do not change the window being displayed. Used when the program rather than a human is to work on a different buffer.
*** insert-buffer-substring
Copy a region of text from a buffer that is passed to the function as an argument and insert the region into the current buffer.
** Comparisons
*** equal
*** greater than
*** less than
*** strings
You can perform comparisons against strings to see if they are greater, less or equal to.
#+BEGIN_SRC emacs-lisp :results code
(when (string> "<2020-09-26 Sat>" "<2020-09-23 Wed>")
  (print "String is greater than the later."))
#+END_SRC

#+begin_src emacs-lisp
"String is greater than the later."
#+end_src

** Conditions
*** if
#+BEGIN_SRC emacs-lisp
(if (eq 1 1)
    (print "good job")
  (print "sorry"))
#+END_SRC
*** when
Is basically an if conditions statement without the else argument.
*** y-or-n-p
#+BEGIN_SRC emacs-lisp
(let ((pos1 (if (y-or-n-p "Do this?")
                (concat "true")
              (concat "false"))))
  (print pos1))
#+END_SRC
*** when-let
*** unless
Basically do not execute the code in the body UNLESS the condition meets the statement
*** if-let
*** not
** Copying & Pasting
*** kill-region
'cut' text between point and mark
*** delete-and-extract-region
Delete the text between START and END and return it.
*** copy-region-as-kill
=copy-region-as-kill= copies the text between point and mark into the kill ring, from which you can get it by yanking. The function does not cut or remove the text from the buffer.
** DOOM Emacs
*** Project
**** ~doom-project-root~
References the currently visiting project folder path
#+BEGIN_SRC emacs-lisp
(doom-project-root)
#+END_SRC
** File System
*** file-in-directory-p
*** file-name-handler-alist
** Data Types
*** type-of
Returns type for OBJECT
#+begin_src emacs-lisp :results code
(type-of org-directory)
#+end_src

#+begin_src emacs-lisp
string
#+end_src

** Evaluate
*** eval
*** eval-and-compile
*** progn
Evaluate each argument in sequence and then return the value of the last.
#+BEGIN_SRC emacs-lisp
(progn 1 2 3 4)
#+END_SRC
** Functions
*** defun
:PROPERTIES:
:ID:       cdd30314-fc37-4df5-9495-42bd73f42a37
:END:
*** interactive options
These are options you'll pass to your =defun= when writing a new function.
- ="p"= to passs a prefix argument
- ="r"= appears to pass two arguments, for instance =beg= and =end=
** Getting User Input
- source :: [[http://ergoemacs.org/emacs/elisp_idioms_prompting_input.html][Elisp: Get User Input]]

You can get user input by multiple symbols:
#+BEGIN_SRC emacs-lisp
(read-directory-name "Directory: " "~/")
(read-string "string: ")
(read-regexp "pattern: ")
#+END_SRC

To select from a list
#+BEGIN_SRC emacs-lisp
(defun my-pick-one ()
  "Prompt user to pick a choice from a list."
  (interactive)
  (let ((choices '("New" "Existing")))
    (message "%s" (org-completing-read "File type: " choices ))))
(my-pick-one)
#+END_SRC
*** read-multiple-choice
Provides a prompt returning options to the user.
#+BEGIN_SRC emacs-lisp
(defun org-gtd--process-inbox-element ()
  "With point on an item, choose which GTD action to take."
  (let ((action
         (read-multiple-choice
          "What to do with this item?"
          '((?q "quick" "quick item: < 2 minutes, done!")
            (?t "throw out" "this has no value to me")
            (?p "project" "multiple steps required to completion")
            (?c "calendar" "do this at a certain time")
            (?d "delegate it" "give it to someone")
            (?s "single action" "do this when possible")
            (?a "archive this knowledge" "Store this where you store knowledge")
            (?i "incubate it" "I'll come back to this later")))))
    (cl-case (car action)
      (?q (org-gtd--quick-action))
      (?t (org-gtd--trash))
      (?p (org-gtd--project))
      (?c (org-gtd--calendar))
      (?d (org-gtd--delegate))
      (?s (org-gtd--single-action))
      (?a (org-gtd--archive))
      (?i (org-gtd--incubate)))))
#+END_SRC
** Lists
*** Setting Lists
**** setq
Define a variable value to a symbol name, seq will also quote the symbol's name for you unlike ~set~.
**** set
Same as ~setq~ but it requires you to quote the symbol's name.
**** mapcar
According to [[https://emacs.stackexchange.com/questions/57909/adding-string-to-each-item-in-list/57910#57910][this post]], ~mapconcat~ and ~mapcar~ are the best way of doing this... here's an example:

#+BEGIN_SRC emacs-lisp
(setq list '("Sample Data" "More Fun"))

(setq list (mapcar (lambda (str)
                     (concat str " is great")) list))

(let ((list '("Sample Data" "More Fun"))
      (tail "is great"))
  (setq list (mapcar (lambda (str)
                       (mapconcat #'identity (list str tail) " ")) list)))
#+END_SRC
**** mapcan
**** setcar
Sets the first item in a list
**** setcdr
Sets the remaining items in a list to what you specify
**** cons
#+BEGIN_SRC emacs-lisp
(cons)
(let ((var '("Data")))
  (car var))
#+END_SRC
**** append
#+BEGIN_SRC emacs-lisp
(setq my-test-var (append (list (concat doom-private-dir (read-string "Enter String: ")))))
#+END_SRC
**** push
*** Reading Lists
**** car
returns the first element of a list
#+BEGIN_SRC emacs-lisp
(car '("First" "Second" "Third"))
#+END_SRC
**** cdr
returns everything after the first element of a list
#+BEGIN_SRC emacs-lisp
(cdr '("First" "Second" "Third"))
#+END_SRC
**** nthcdr
Returns the Nth place in a list
#+BEGIN_SRC emacs-lisp
(nthcdr 3 '("Some" "First" "Data" "to" "Consider"))
#+END_SRC
**** nth
read from a index value of a list.
#+BEGIN_SRC emacs-lisp :results code
(nth 2 '("Emacs" "great" "tool" "for" "everyone"))
#+END_SRC

#+begin_src emacs-lisp
"tool"
#+end_src

** Loops
*** cl-loop
#+BEGIN_SRC emacs-lisp
(cl-loop for i from 1 to 5
         collect i)
#+END_SRC
*** while
While is basically like if, however, if the evaluation is false, then it skips the body. If however, it is true, then it executes what is in the body and then re-runs the evaluation. This is *important* to note because, this essentially creates a loop until the statement is false. EG: *Asking a user to input something until nil*

It is also noted, that you can use cdr to shorten a list while running a while loop. You do so, by assigning a statement like so in your while loop =(setq animals (cdr animals))=
*** do-list
** Position
*** goto-char
Set point to the location specified by the value of the argument, which can be a number, a marker, or an expression that returns the number of a position, such as =(point-min)=.
*** push-mark
Set mark at a location and record the value of the previous mark on the mark ring. The mark is a location in the buffer that will keep its relative position even if text is added to or removed from the buffer.
*** save-excursion
Save the location of point and restore its value after the arguments to save-excursion have been evaluated. Also, remember the current buffer and return to it.
*** save-restriction
Comes in hand
*** register
Stores the location in it's buffer and position
** Read From
*** thing-at-point
Will read whatever is at point.
#+BEGIN_SRC emacs-lisp :results code
(thing-at-point 'line t)
#+END_SRC

#+begin_src emacs-lisp
"(thing-at-point 'line t)\n"
#+end_src

** Searching
*** string-match
*** search-forward
Basically search for a string, and if found, move point to that string.
** Strings
*** match-string
*** split-string
Splits the string into indexes.
#+BEGIN_SRC emacs-lisp :results code
(split-string "Emacs is awesome")
#+END_SRC

#+begin_src emacs-lisp
("Emacs" "is" "awesome")
#+end_src
*** substring
Breaks a string into a range specified by arguments.
#+BEGIN_SRC emacs-lisp :results code
(substring "Emacs is awesome" 6 16)
#+END_SRC

#+begin_src emacs-lisp
"is awesome"
#+end_src

** Variables
*** defvar
Define a variable, unless a value is already assigned to the symbol's name. If you're expecting this to be customizable, use ➤ ~defcusotm~
#+BEGIN_SRC emacs-lisp
(defvar my-symbol '"hello")
#+END_SRC
*** defcustom
Useful to create a symbol variable, that's also available via the customization group. (see Widgets)
#+BEGIN_SRC emacs-lisp
(defcustom my-new-symbol "value"
  "Documentation."
  :type 'string)
#+END_SRC
*** let
Assign temporary variables, commonly used in functions and maybe lambda functions.
*** let*
** catch
#+BEGIN_SRC emacs-lisp
(defun foo-catch ()
  "Catch my throw"
  (catch 'foo
    (foo-inner)))

(foo-catch)
(foo-throw)

(defun foo-throw ()
  "Throw my catch"
  (if x
      (throw 'foo t)
    (print "Good throw")))
#+END_SRC
** condition-case
:PROPERTIES:
:ID:       db12ee10-cbaa-485f-8a9a-f422cce6b502
:END:
kill-region explains in more detail what condition-case does with an example. But basically, if your first argument is =nil= then the error is not stored and will not be passed to anything else in the body. The second argument tells elisp what to do if all goes well. The third argument tells elisp what to do if an error is encountered.
** declare
** defalias
** error
** funcall
evaluated first argument as a function, passes remaining arguments to its first argument (feeding arguments into a function)
#+BEGIN_SRC elisp
(funcall (intern "-") 1 2 3)
(funcall (intern "+") 1 2 3)
#+END_SRC
** intern
Return the canonical symbol whose name is STRING.
#+BEGIN_SRC emacs-lisp
(intern "string")
#+END_SRC

*** TODO what is canonical symbol?
** keywordp
** last command
Provides the last command that was ran
** memq
** pcase
** plist
** plist-get
** plist-put
** prependq!
** puthash
** save-match-data
** signal
** with-eval-after-load
:PROPERTIES:
:ID:       d8609736-44fe-403c-97a6-119d02d4ff57
:END:
